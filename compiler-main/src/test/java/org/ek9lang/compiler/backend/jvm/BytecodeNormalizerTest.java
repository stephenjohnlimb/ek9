package org.ek9lang.compiler.backend.jvm;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import javax.tools.JavaCompiler;
import javax.tools.ToolProvider;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

/**
 * Tests for BytecodeNormalizer using javac-compiled test classes.
 * <p>
 * This approach validates the normalizer against known-good bytecode
 * from the standard Java compiler before using it with EK9-generated bytecode.
 * </p>
 */
class BytecodeNormalizerTest {

  @TempDir
  static Path tempDir;

  private static Path compiledClassesDir;

  /**
   * Compile test Java classes once before all tests.
   */
  @BeforeAll
  static void compileTestClasses() throws Exception {
    compiledClassesDir = tempDir.resolve("classes");
    Files.createDirectories(compiledClassesDir);

    // Get path to test Java source files
    final File resourcesDir = new File("src/test/resources/bytecode-test-classes");
    if (!resourcesDir.exists()) {
      throw new RuntimeException(
          "Test resources directory not found: " + resourcesDir.getAbsolutePath());
    }

    // Compile all .java files in test resources
    final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
    if (compiler == null) {
      throw new RuntimeException("No Java compiler available - are you running with a JDK?");
    }

    final File[] javaFiles = resourcesDir.listFiles((_, name) -> name.endsWith(".java"));
    if (javaFiles == null || javaFiles.length == 0) {
      throw new RuntimeException("No test Java files found in " + resourcesDir);
    }

    // Compile with output to temp directory (with debug info enabled)
    final String[] args = new String[javaFiles.length + 3];
    args[0] = "-g";  // Enable debug information generation
    args[1] = "-d";
    args[2] = compiledClassesDir.toString();
    for (int i = 0; i < javaFiles.length; i++) {
      args[i + 3] = javaFiles[i].getAbsolutePath();
    }

    final int result = compiler.run(System.in, System.out, System.err, args);
    if (result != 0) {
      throw new RuntimeException("Compilation failed with exit code " + result);
    }
  }

  /**
   * Test normalization with ultra-simple class (baseline).
   * Verifies basic normalization functionality.
   */
  @Test
  void testNormalizeSimpleClass() throws Exception {
    final String expected = """
        public class TestClass1 {
          public TestClass1();
            Code:
                 0: aload_0
                 1: invokespecial #CP                  // Method java/lang/Object."<init>":()V
                 4: return
              LineNumberTable:
                line 8: 0

          public int add(int, int);
            Code:
                 0: iload_1
                 1: iload_2
                 2: iadd
                 3: ireturn
              LineNumberTable:
                line 18: 0
        }""";

    assertNormalizedBytecode("TestClass1.class", expected);
  }

  /**
   * Test normalization with branching (labels, conditionals).
   * Verifies that control flow instructions are preserved.
   */
  @Test
  void testNormalizeWithBranching() throws Exception {
    final String expected = """
        public class TestClass2 {
          public TestClass2();
            Code:
                 0: aload_0
                 1: invokespecial #CP                  // Method java/lang/Object."<init>":()V
                 4: return
              LineNumberTable:
                line 8: 0

          public java.lang.String checkNull(java.lang.String);
            Code:
                 0: aload_1
                 1: ifnonnull     7
                 4: ldc           #CP                  // String null
                 6: areturn
                 7: aload_1
                 8: areturn
              LineNumberTable:
                line 17: 0
                line 18: 4
                line 20: 7
        }""";

    assertNormalizedBytecode("TestClass2.class", expected);
  }

  /**
   * Test normalization with multiple methods and fields.
   * Verifies field access and constructor handling.
   */
  @Test
  void testNormalizeWithFieldsAndConstructor() throws Exception {
    final String expected = """
        public class TestClass3 {
          private int field;

          public TestClass3(int);
            Code:
                 0: aload_0
                 1: invokespecial #CP                  // Method java/lang/Object."<init>":()V
                 4: aload_0
                 5: iload_1
                 6: putfield      #CP                  // Field field:I
                 9: return
              LineNumberTable:
                line 18: 0
                line 19: 4
                line 20: 9

          public int getField();
            Code:
                 0: aload_0
                 1: getfield      #CP                  // Field field:I
                 4: ireturn
              LineNumberTable:
                line 28: 0
        }""";

    assertNormalizedBytecode("TestClass3.class", expected);
  }

  /**
   * Test that normalizer handles null input gracefully.
   */
  @Test
  void testNormalizeNullInput() {
    assertThrows(IllegalArgumentException.class,
        () -> BytecodeNormalizer.normalize(null), "Should throw IllegalArgumentException for null input");
  }

  /**
   * Test that normalizer handles empty byte array gracefully.
   */
  @Test
  void testNormalizeEmptyInput() {
    assertThrows(IllegalArgumentException.class,
        () -> BytecodeNormalizer.normalize(new byte[0]), "Should throw IllegalArgumentException for empty input");
  }

  /**
   * Test that normalizer handles invalid class bytes gracefully.
   */
  @Test
  void testNormalizeInvalidClassBytes() {
    final byte[] invalidBytes = "not a class file".getBytes();

    assertThrows(RuntimeException.class,
        () -> BytecodeNormalizer.normalize(invalidBytes), "Should throw RuntimeException for invalid class bytes");
  }

  /**
   * Helper method to assert normalized bytecode matches expected output.
   *
   * @param className Name of .class file (e.g., "TestClass1.class")
   * @param expected  Expected normalized bytecode
   */
  private void assertNormalizedBytecode(final String className, final String expected)
      throws Exception {
    final byte[] classBytes = loadCompiledClass(className);
    final String actual = BytecodeNormalizer.normalize(classBytes);
    assertEquals(expected, actual,
        "Normalized bytecode should match expected output for " + className);
  }

  /**
   * Helper method to load compiled .class file as byte array.
   *
   * @param className Name of .class file (e.g., "TestClass1.class")
   * @return Byte array of compiled class
   */
  private byte[] loadCompiledClass(final String className) throws Exception {
    final Path classFile = compiledClassesDir.resolve(className);
    if (!Files.exists(classFile)) {
      throw new RuntimeException("Compiled class not found: " + classFile);
    }
    return Files.readAllBytes(classFile);
  }
}
