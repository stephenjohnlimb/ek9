package org.ek9lang.compiler.bytecode;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.File;
import java.nio.file.Files;
import java.util.List;
import java.util.function.Predicate;
import org.ek9lang.compiler.CompilableProgram;
import org.ek9lang.compiler.CompilableSource;
import org.ek9lang.compiler.CompilationPhase;
import org.ek9lang.compiler.backend.jvm.BytecodeNormalizer;
import org.ek9lang.compiler.common.PhasesTest;
import org.ek9lang.compiler.support.SymbolCountCheck;
import org.ek9lang.core.TargetArchitecture;
import org.junit.jupiter.api.Test;

/**
 * Base class for bytecode generation tests.
 * Extends PhasesTest to compile EK9 source files through to the CODE_GENERATION_AGGREGATES phase
 * and validate generated JVM bytecode using @BYTE_CODE directives.
 *
 * <h2>CRITICAL: One Directory Per Test Pattern</h2>
 * <p>
 * Unlike IR generation tests, bytecode tests MUST follow a strict one-directory-per-test pattern
 * to enable safe parallel execution. Each test spawns a javap subprocess and performs expensive
 * disk I/O operations that would cause race conditions if multiple tests shared the same .ek9
 * output directory.
 * </p>
 *
 * <h3>Directory Structure (CORRECT)</h3>
 * <pre>
 * bytecodeGeneration/
 *   helloWorld/
 *     helloWorld.ek9              → HelloWorldTest
 *   basicAssignment/
 *     basicAssignment.ek9         → BasicAssignmentTest
 *   guardedAssignment/
 *     guardedAssignment.ek9       → GuardedAssignmentTest
 *   isSetOperator/
 *     isSetOperator.ek9        → QuestionOperatorTest
 * </pre>
 *
 * <h3>Why This Pattern is Required</h3>
 * <ul>
 *   <li><b>Parallel Execution:</b> Each test spawns javap subprocess (expensive I/O)</li>
 *   <li><b>Directory Isolation:</b> testPhaseDevelopment() calls cleanEk9DirectoryStructureFor()</li>
 *   <li><b>Race Condition Prevention:</b> Multiple tests cleaning same .ek9/ directory = failures</li>
 *   <li><b>File Contention:</b> Concurrent .class file writes/reads in same directory = corruption</li>
 *   <li><b>Performance:</b> 25-35 tests × javap = significant speedup with parallelism</li>
 * </ul>
 *
 * <h3>Anti-Pattern (WRONG - DO NOT DO THIS)</h3>
 * <pre>
 * bytecodeGeneration/
 *   assignmentStatements/
 *     basicAssignment.ek9         ← Multiple files = directory contention
 *     guardedAssignment.ek9       ← Would cause race conditions
 *     multipleAssignments.ek9     ← When run in parallel
 * </pre>
 *
 * <h3>Test Class Pattern</h3>
 * <pre>{@code
 * class BasicAssignmentTest extends AbstractBytecodeGenerationTest {
 *   public BasicAssignmentTest() {
 *     // Each test points to its OWN directory with ONE .ek9 file
 *     super("/examples/bytecodeGeneration/basicAssignment",
 *         List.of(new SymbolCountCheck("module.name", 1)),
 *         false, false, false);
 *   }
 * }
 * }</pre>
 */
public abstract class AbstractBytecodeGenerationTest extends PhasesTest {

  private final List<SymbolCountCheck> expectedSymbols;
  private final boolean showBytecode;

  public AbstractBytecodeGenerationTest(final String fromResourcesDirectory,
                                        final List<SymbolCountCheck> expectedSymbols, final boolean verbose,
                                        final boolean muteReportedErrors, final boolean showBytecode) {
    super(fromResourcesDirectory, verbose, muteReportedErrors);
    this.expectedSymbols = expectedSymbols;
    this.showBytecode = showBytecode;
    if (showBytecode) {
      System.err.println("Warning: Show bytecode is enabled for " + fromResourcesDirectory);
    }
  }

  /**
   * Enable debug instrumentation for bytecode generation.
   *
   * @return true to enable debug instrumentation.
   */
  @Override
  protected boolean addDebugInstrumentation() {
    return true;
  }

  @Test
  void testPhaseDevelopment() {
    //Clean out any existing targets for this unit test
    ek9Workspace.getSources().stream().findFirst()
        .ifPresent(source -> fileHandling.cleanEk9DirectoryStructureFor(source.getFileName(), targetArchitecture));

    testToPhase(CompilationPhase.CODE_GENERATION_AGGREGATES);
  }

  @Override
  protected void assertFinalResults(final boolean compilationResult, final int numberOfErrors,
                                    final CompilableProgram program) {
    assertTrue(compilationResult);
    assertEquals(0, numberOfErrors);
    expectedSymbols.forEach(check -> check.test(program));
    if (showBytecode) {
      showBytecode(program);
    }

  }

  /**
   * Display generated bytecode for debugging purposes.
   * Finds all generated .class files and normalizes them with javap for inspection.
   */
  protected void showBytecode(final CompilableProgram program) {
    System.out.println("=== Generated Bytecode ===");

    expectedSymbols.forEach(symbolCheck -> {
      final var moduleName = symbolCheck.getForModuleName();

      final Predicate<CompilableSource> sameModule = compilableSource
          -> program.getParsedModuleForCompilableSource(compilableSource).getModuleName().equals(moduleName);

      //Locate .ek9 output directory
      ek9Workspace.getSources().stream()
          .filter(sameModule)
          .findFirst()
          .ifPresent(source -> {
            try {
              final var projectDir = new File(source.getFileName()).getParent();
              final var dotEk9Dir = fileHandling.getDotEk9Directory(projectDir);
              final var outputDir = fileHandling.getMainGeneratedOutputDirectory(dotEk9Dir, TargetArchitecture.JVM);

              //Find and display all .class files
              try (var paths = Files.walk(outputDir.toPath())) {
                paths.filter(path -> path.toString().endsWith(".class"))
                    .forEach(classPath -> {
                      try {
                        System.out.println("\nClass file: " + classPath.getFileName());
                        final byte[] classBytes = Files.readAllBytes(classPath);
                        final String normalized = BytecodeNormalizer.normalize(classBytes);
                        System.out.println(normalized);
                      } catch (Exception e) {
                        System.err.println("Failed to read/normalize: " + classPath + " - " + e.getMessage());
                      }
                    });
              }
            } catch (Exception e) {
              System.err.println("Failed to walk directory: " + e.getMessage());
            }
          });
    });
  }
}
