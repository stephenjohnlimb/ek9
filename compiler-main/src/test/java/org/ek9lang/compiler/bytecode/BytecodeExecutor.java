package org.ek9lang.compiler.bytecode;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Path;

/**
 * Executes generated EK9 bytecode within the current JVM for testing purposes.
 * This avoids spawning external JVM processes for each test execution,
 * significantly improving test performance.
 *
 * <p>The executor uses a URLClassLoader to load generated .class files from
 * the compilation output directory. The ek9-lang runtime classes are loaded
 * from the test classpath (parent-first delegation).</p>
 *
 * <p>Output capture is achieved using a thread-local PrintStream. Each test thread
 * captures its own output independently, enabling parallel-safe test execution.
 * EK9 programs use Stdout which writes to System.out, but we redirect System.out
 * to a thread-local delegating stream.</p>
 */
public final class BytecodeExecutor {

  private static final PrintStream ORIGINAL_OUT = System.out;
  private static final ThreadLocalPrintStream DELEGATING_OUT = new ThreadLocalPrintStream(ORIGINAL_OUT);

  static {
    // Install the delegating PrintStream once at class load time
    System.setOut(DELEGATING_OUT);
  }

  private BytecodeExecutor() {
    // Utility class - no instantiation
  }

  /**
   * Executes a generated EK9 program and returns its captured stdout output.
   *
   * <p>This method is thread-safe and can be called from parallel test threads.
   * Each thread captures its own output independently.</p>
   *
   * @param bytecodeDir      Directory containing generated .class files
   * @param programClassName Fully qualified class name (e.g., "bytecode.test.MyProgram")
   * @param args             String arguments to pass to _main() method
   * @return The captured stdout output from the program
   * @throws Exception if execution fails
   */
  public static String execute(final Path bytecodeDir,
                               final String programClassName,
                               final String... args) throws Exception {

    // Set up thread-local output capture
    final ByteArrayOutputStream outputCapture = new ByteArrayOutputStream();
    ThreadLocalPrintStream.setThreadOutput(outputCapture);

    try {
      // Create ClassLoader for generated bytecode
      // Parent-first delegation ensures ek9-lang classes come from test classpath
      try (URLClassLoader classLoader = new URLClassLoader(
          new URL[]{bytecodeDir.toUri().toURL()},
          BytecodeExecutor.class.getClassLoader())) {

        // Load the program class
        final Class<?> programClass = classLoader.loadClass(programClassName);

        // Find the _main method
        final Method mainMethod = findMainMethod(programClass);
        if (mainMethod == null) {
          throw new NoSuchMethodException("No _main method found in " + programClassName);
        }

        // Convert arguments to EK9 types
        final Object[] ek9Args = convertArguments(mainMethod.getParameterTypes(), args);

        // Create program instance and invoke _main
        final Object programInstance = programClass.getDeclaredConstructor().newInstance();
        try {
          mainMethod.invoke(programInstance, ek9Args);
        } catch (InvocationTargetException e) {
          // Capture exception output like Java does for uncaught exceptions
          formatExceptionOutput(e.getCause(), programClassName, outputCapture);
        }
      }

      // Get captured output
      return ThreadLocalPrintStream.clearAndGet();
    } finally {
      // Ensure thread-local is cleared even on exception
      ThreadLocalPrintStream.clearAndGet();
    }
  }

  /**
   * Finds the _main method in the program class.
   * EK9 programs have a _main() method that may take various argument types.
   */
  private static Method findMainMethod(final Class<?> programClass) {
    for (Method method : programClass.getMethods()) {
      if ("_main".equals(method.getName())) {
        return method;
      }
    }
    return null;
  }

  /**
   * Converts Java String arguments to EK9 runtime types.
   * EK9 programs expect org.ek9.lang.* types as parameters.
   */
  private static Object[] convertArguments(final Class<?>[] paramTypes, final String[] args) {
    if (paramTypes.length == 0) {
      return new Object[0];
    }

    if (args.length != paramTypes.length) {
      throw new IllegalArgumentException(
          "Argument count mismatch: expected " + paramTypes.length + ", got " + args.length);
    }

    final Object[] converted = new Object[args.length];
    for (int i = 0; i < args.length; i++) {
      converted[i] = convertArgument(paramTypes[i], args[i]);
    }
    return converted;
  }

  /**
   * Converts a single String argument to the expected EK9 type.
   */
  private static Object convertArgument(final Class<?> paramType, final String value) {
    final String typeName = paramType.getName();

    return switch (typeName) {
      case "org.ek9.lang.String" -> org.ek9.lang.String._of(value);
      case "org.ek9.lang.Integer" -> org.ek9.lang.Integer._of(value);
      case "org.ek9.lang.Float" -> org.ek9.lang.Float._of(value);
      case "org.ek9.lang.Boolean" -> org.ek9.lang.Boolean._of(value);
      default -> throw new IllegalArgumentException(
          "Unsupported parameter type: " + typeName + " for value: " + value);
    };
  }

  /**
   * Formats an uncaught exception output like Java does when exceptions reach main().
   * Format: "Exception in thread \"main\" [exception.toString()]\n\tat [stacktrace]"
   */
  private static void formatExceptionOutput(final Throwable cause,
                                            final String programClassName,
                                            final ByteArrayOutputStream outputCapture) {
    final PrintStream ps = new PrintStream(outputCapture);

    // Format the exception header - use toString() which includes the message for EK9 exceptions
    ps.print("Exception in thread \"main\" ");
    ps.println(cause.toString());

    // Print filtered stack trace
    for (StackTraceElement element : cause.getStackTrace()) {
      final String className = element.getClassName();
      // Only include program class frames, skip reflection internals
      if (className.equals(programClassName)) {
        ps.print("\tat ");
        ps.print(className);
        ps.print(".");
        ps.print(element.getMethodName());
        ps.print("(");
        if (element.getFileName() != null) {
          ps.print(element.getFileName());
        } else {
          ps.print("Unknown Source");
        }
        ps.println(")");
      }
    }

    // Add synthetic ek9.Main frame to match expected output format
    ps.println("\tat ek9.Main.main(Unknown Source)");
  }
}
