#!ek9
<?-
  Unicode Mutation Test: Combining Characters and Special Cases
  Tests compiler handling of combining marks, zero-width characters, etc.

  Validates: Combining diacriticals, zero-width joiners, normalization forms
  Identifiers remain ASCII, complex Unicode only in strings.

  Should compile successfully - no errors expected.
-?>
defines module fuzztest.mutation.valid.unicode.combining

  defines function

    testCombiningDiacriticals()
      // Base character + combining diacritical marks
      e_acute <- "Ã©"          // e + combining acute (U+0301)
      n_tilde <- "Ã±"          // n + combining tilde (U+0303)
      a_ring <- "Ã¥"           // a + combining ring above (U+030A)

      // Multiple combining marks on same base
      complex <- "á»‡"          // e + circumflex + dot below

      assert e_acute?
      assert n_tilde?
      assert a_ring?
      assert complex?

    testCombiningSequences()
      // Longer sequences with combining marks
      vietnamese <- "Tiáº¿ng Viá»‡t"     // Vietnamese with tone marks
      turkish <- "Ä°stanbul"           // Turkish with dotted I
      polish <- "ÅÃ³dÅº"                // Polish with stroke

      assert vietnamese?
      assert turkish?
      assert polish?

    testZeroWidthJoiner()
      // Zero-Width Joiner (ZWJ) - used in emoji and Indic scripts
      family_emoji <- "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦"      // ZWJ sequences
      indian <- "à¤•à¥à¤·"                  // Devanagari with ZWJ

      assert family_emoji?
      assert indian?

    testZeroWidthNonJoiner()
      // Zero-Width Non-Joiner (ZWNJ) - prevents ligatures
      persian <- "Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡Ù…"          // Persian with ZWNJ

      assert persian?

    testZeroWidthSpace()
      // Zero-Width Space (ZWSP) - invisible word break
      with_zwsp <- "wordâ€‹break"       // Contains U+200B between words

      assert with_zwsp?

    testNormalizationForms()
      // Same visual character, different Unicode representations
      // NFC (composed): Ã© = U+00E9
      nfc_form <- "cafÃ©"

      // NFD (decomposed): Ã© = e (U+0065) + Ì (U+0301)
      nfd_form <- "cafÃ©"

      // Both should be valid strings
      assert nfc_form?
      assert nfd_form?

    testVariationSelectors()
      // Variation selectors change character presentation
      text_style <- "â˜ºï¸Ž"       // Text presentation
      emoji_style <- "â˜ºï¸"      // Emoji presentation

      assert text_style?
      assert emoji_style?

    testDirectionalMarks()
      // Left-to-Right Mark (LRM) and Right-to-Left Mark (RLM)
      with_lrm <- "Testâ€ŽText"  // Contains LRM (U+200E)
      with_rlm <- "Testâ€Text"  // Contains RLM (U+200F)

      assert with_lrm?
      assert with_rlm?

    testControlCharacters()
      // Soft hyphen (invisible unless at line break)
      with_soft_hyphen <- "softÂ­hyphen"  // Contains U+00AD

      // Non-breaking space
      with_nbsp <- "non breaking"        // Contains U+00A0

      assert with_soft_hyphen?
      assert with_nbsp?

    testUnicodeNormalization()
      // Test that different normalizations are handled
      precomposed <- "Î©"     // Ohm sign U+2126
      omega <- "Î©"            // Greek capital omega U+03A9

      // Both should work in strings
      assert precomposed?
      assert omega?

    testComplexCombiningSequences()
      // Multiple combining marks creating complex glyphs
      devanagari <- "à¤¹à¤¿à¤¨à¥à¤¦à¥€"            // Hindi with multiple combining marks
      thai <- "à¸ à¸²à¸©à¸²à¹„à¸—à¸¢"                  // Thai with tone marks
      arabic_marks <- "Ø§ÙŽÙ„Ù’Ø¹ÙŽØ±ÙŽØ¨ÙÙŠÙŽÙ‘Ø©"   // Arabic with diacriticals

      assert devanagari?
      assert thai?
      assert arabic_marks?

    testEdgeCases()
      // Grapheme clusters that span multiple code points
      flag_england <- "ðŸ´ó §ó ¢ó ¥ó ®ó §ó ¿"  // Flag: England (7 code points!)
      keycap <- "5ï¸âƒ£"                     // Keycap 5

      assert flag_england?
      assert keycap?

//EOF
