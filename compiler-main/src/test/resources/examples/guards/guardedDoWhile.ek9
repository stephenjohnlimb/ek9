#!ek9
defines module some.ok.dowhileguards

  <!-
    First few records and functions here are the test fixtures.
  -!>
  defines record

    //Note that this has no 'is-set' operator but 'Any' does
    UnusableAggregate
      name <- String()

    //But this does have the 'is-set' operator, overriding/defaulting its implementation.
    UsableAggregate
      name <- String()

      default operator ?

  defines function

    <?-
      Simple function to provide an aggregate (record in this case)
      that does not have the 'is-set' operator directly.
    -?>
    provideUnusableReturn()
      <- rtn <- UnusableAggregate()

    <?-
      Provide a usable aggregate
    -?>
    provideUsableReturn()
      <- rtn <- UsableAggregate()

    <!-
      These are the demonstrations the prove the positive use and also the negative use.
    -!>

    demonstrateValidDoWhileAssignmentUse1()
      -> conditional as Boolean

      stdout <- Stdout()
      //Note still use UnusableAggregate without an 'is-set' operator, to show it can be used like this.
      //So this does not use the 'guard' functionality - i.e. there is no is-set functionality triggered.
      toCheck <- UnusableAggregate()
      do toCheck := provideUnusableReturn()
        stdout.println(`But this is just a blind assignment ${toCheck.name}`)
      while conditional

    demonstrateValidDoWhileAssignmentUse2()
      -> conditional as Boolean

      stdout <- Stdout()

      //Just for completeness really
      toCheck <- UsableAggregate()
      do toCheck := provideUsableReturn()
        stdout.println(`But this is just a blind assignment ${toCheck.name}`)
      while conditional

    demonstrateValidDoWhileExpressionAssignmentUse1()
      -> conditional as Boolean

      stdout <- Stdout()
      //Note still use UnusableAggregate without an 'is-set' operator, to show it can be used like this.
      //So this does not use the 'guard' functionality - i.e. there is no is-set functionality triggered.
      toCheck <- UnusableAggregate()
      result <- do toCheck := provideUnusableReturn()
        <- rtn as String: toCheck.name
        stdout.println(`But this is just a blind assignment ${toCheck.name}`)
      while conditional
      assert result?

    demonstrateValidDoWhileExpressionAssignmentUse2()
      -> conditional as Boolean

      stdout <- Stdout()

      //Just for completeness really
      toCheck <- UsableAggregate()
      result <- do toCheck := provideUsableReturn()
        <- rtn as String: toCheck.name
        stdout.println(`But this is just a blind assignment ${toCheck.name}`)
      while conditional
      assert result?

    demonstrateValidDoWhileDeclarationUse()
      -> conditional as Boolean

      stdout <- Stdout()

      do toCheck <- provideUsableReturn()
        stdout.println(`Do expect this to compile and maybe see ${toCheck.name}`)
      while conditional

    demonstrateValidDoWhileExpressionDeclarationUse()
      -> conditional as Boolean

      stdout <- Stdout()

      result <- do toCheck <- provideUsableReturn()
        <- rtn as String: toCheck.name
        stdout.println(`Do expect this to compile and maybe see ${toCheck.name}`)
      while conditional
      assert result?

    demonstrateValidDoWhileGuardedAssignmentUse()
      -> conditional as Boolean

      stdout <- Stdout()

      //As the UsableAggregate does have an is-set operator it can be used in the 'guard' statement.
      toCheck <- UsableAggregate()
      do toCheck ?= provideUsableReturn()
        stdout.println(`Do expect this to compile and maybe see ${toCheck.name}`)
      while conditional

    <!-
      Now the other scenarios that depend on 'Any' '?' operator.
    -!>

    demonstrateValidDoWhileGuardedAssignmentUseViaAny()
      -> conditional as Boolean

      stdout <- Stdout()

      //Even though it has not ? operator the implicit super 'Any' does and that's what will be used.
      toCheck <- UnusableAggregate()

      do toCheck ?= provideUnusableReturn()
        stdout.println(`Will compile by using Any ? ${toCheck.name}`)
      while conditional

    demonstrateValidDoWhileDeclarationUseViaAny1()
      -> conditional as Boolean

      stdout <- Stdout()

      //So even though this is a declaration of toCHeck, the ? operator will still be called
      //after toCheck has been initialised to see if it is 'set', if not then the loop will not execute.
      do toCheck <- provideUnusableReturn()
        stdout.println(`Will compile by using Any ? ${toCheck.name}`)
      while conditional

    demonstrateValidDoWhileDeclarationUseViaAny2()
      -> conditional as Boolean

      stdout <- Stdout()

      do toCheck as UnusableAggregate: provideUnusableReturn()
        stdout.println(`Will compile by using Any ? ${toCheck.name}`)
      while conditional

    demonstrateValidDoWhileExpressionDeclarationUseViaAny1()
      -> conditional as Boolean

      stdout <- Stdout()

      result <- do toCheck <- provideUnusableReturn()
        <- rtn as String: toCheck.name
        stdout.println(`Will compile by using Any ? ${toCheck.name}`)
      while conditional
      assert result?

    demonstrateValidDoWhileExpressionDeclarationUseViaAny2()
      -> conditional as Boolean

      stdout <- Stdout()

      result <- do toCheck as UnusableAggregate: provideUnusableReturn()
        <- rtn as String: toCheck.name
        stdout.println(`Will compile by using Any ? ${toCheck.name}`)
      while conditional
      assert result?

//EOF