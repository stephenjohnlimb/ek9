#!ek9
<?-
  Checks various tye of assignment - including coalescing.
-?>
defines module bad.coalescing.assignments

  defines class
    C1
      prop1 as String: String()
      default C1()

      checkAccess()
        this.prop1: "Steve"

  defines component

    Base as abstract
      default Base()

      aMethod() as abstract
        -> arg0 as String
        <- rtn as Boolean?

    Comp1 extends Base as abstract
      default Comp1()

      override operator ? as pure
        <- rtn <- true

    Comp2 extends Comp1
      default Comp2()

      override aMethod()
        -> arg0 as String
        <- rtn as Boolean: arg0?

  defines function

    GetStartValue()
      <- rtn <- 1

    <?-
      Show that even in a guard an assignment to incoming parameters is not allowed.
    -?>
    TestGuardAssignment()
      -> var as Integer

      @Error: FULL_RESOLUTION: NO_INCOMING_ARGUMENT_REASSIGNMENT
      if var :=? GetStartValue() then var < 10
        otherValue <- var
        assert var? and otherValue?

      val <- var
      assert val?

    JustFail()
      @Error: FULL_RESOLUTION: NOT_RESOLVED
      assert failure

    TestSimpleAssignment1()

      @Error: FULL_RESOLUTION: NOT_REFERENCED
      var1 as String?

      //This is an assignment and not a reference (use)
      var1: "Steve"

    TestSimpleAssignment2()

      var1 as String?
      var1: "Steve"
      //Now it's been referenced (used).
      assert var1?

    TestSimpleAssignment3()

      //Expect injection - but it never comes!
      var1 as Comp1!

      //Hey we've marked this for injection, you cannot just reassign like this use :=?
      //i.e. a conditional reassignment (only if null/unset)
      @Error: FULL_RESOLUTION: REASSIGNMENT_OF_INJECTED_COMPONENT
      var1: Comp2()
      //Now it's been referenced (used).
      assert var1?

    TestSimpleAssignment4()

      //Expect injection - but it never comes!
      var1 as Base!

      //and you cannot assign it.
      @Error: FULL_RESOLUTION: REASSIGNMENT_OF_INJECTED_COMPONENT
      var1 :=? Comp2()

      assert var1?

    TestSimpleAssignmentViaParameter1()
      -> var1 as String
      //You cannot do this - no assignment to incoming arguments is allowed
      @Error: FULL_RESOLUTION: NO_INCOMING_ARGUMENT_REASSIGNMENT
      var1: "Steve"

    TestSimpleAssignmentViaParameter2()
      -> var1 as String

      //Any you cannot do this either.
      @Error: FULL_RESOLUTION: NO_INCOMING_ARGUMENT_REASSIGNMENT
      var1 :=? "Steve"


    TestCoalescingAssignment1()
      //Created, given memory but left 'unset'
      someVar <- String()

      //In this case the variable will be assigned because it is unset.
      someVar :=? "Steve"

      assert someVar == "Steve"

    TestCoalescingAssignment2()
      //So obviously not set
      someVar as String?

      //In this case the variable will be assigned because it is unset.
      someVar :=? "Steve"

      assert someVar == "Steve"

    TestCoalescingAssignment3()
      //Maybe not set
      someComp as Comp1!

      //In this case the variable will be assigned because it might be unset.
      //But this approach is not allowed work with a new variable
      @Error: FULL_RESOLUTION: REASSIGNMENT_OF_INJECTED_COMPONENT
      someComp :=? Comp2()
      assert someComp?

      //Better idiomatic approach, never allow reassignment of injected components
      //Always use a new variable and if the injected value is there use that or create a new component to use.
      workingComp <- someComp? <- someComp else Comp2()
      assert workingComp?

    TestBadCoalescingAssignment2()
      @Error: FULL_RESOLUTION: NOT_REFERENCED
      aC1 <- C1()

      aC1 :=? C1()

    TestBadCoalescingAssignment3()
      @Error: FULL_RESOLUTION: NOT_REFERENCED
      aC1 as C1?

      aC1 :=? C1()

//EOF