#!ek9
<?-
  This example shows that a class with multiple traits can have methods that match
  that are the same weight and are therefore ambiguous and neither the developer nor the
  compiler can reasonably determine when methods should be called.

  Struggling to create a scenario that creates same weight of match.
-?>
defines module ambiguous.methods.two

  defines class

    C1 as open
      default C1 as pure

      override operator ? as pure
        <- rtn <- true

    C2 extends C1
      default C2 as pure

      override operator ? as pure
        <- rtn <- true

  defines trait
    T1
      methodA()
        -> c1 as C1
        assert c1?

      methodA()
        -> a1 as Any
        assert a1?

    T2
      methodA()
        -> c2 as C2
        assert c2?

      methodA()
        -> a1 as Any
        assert a1?

  defines class
    TheTees with trait of T1, T2
      override methodA()
        -> a1 as Any
        assert a1?

  defines program

    TestProgram1()

      //Just to trigger an error until I can create scenario
      unused <- 8

      c1 <- C1()
      c2 <- C2()
      a1 as Any := c2

      ts <- TheTees()

      ts.methodA(c1)
      ts.methodA(c2)
      ts.methodA(a1)


//EOF

