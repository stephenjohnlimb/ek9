#!ek9
<?-
  Demonstration, that shows type coercion leading to method resolution ambiguity.
  Then how a developer can resolve that ambiguity.
  Also shows that automatic coercion in method resolution is constrained to a single
  coercion/promotion.

  This latter point is by design, to prevent possible circular coercion loops but also
  to make it much clearer to a developer. Otherwise small changes in classes adding/removing
  coercions in deeply nest type hierarchies (not a good idea) would lead to issues in code
  that was 'far distant' in its definition.
  What I mean by this is weird side effects in your code when some other API has coercion changes.

  So by limiting automatic coercion to one single coercion per type (when resolving methods), it becomes
  easier for the developer to just look at the type they are passing in and see a single coercion, rather
  than having to chase the coercions through the type hierarchy.
-?>
defines module ambiguous.methods.three

  defines class

    C1
      default C1 as pure

      //Can be coerced to an Integer
      operator #^ as pure
        <- rtn as Integer: 1

      override operator ? as pure
        <- rtn <- true

    C2
      default C2 as pure

      operator #^ as pure
        <- rtn as Integer: 1

      //Can be coerced to an Integer
      override operator ? as pure
        <- rtn <- true

    C3
      default C3 as pure

      //Can be coerced to a C2
      operator #^ as pure
        <- rtn as C2: C2()

      override operator ? as pure
        <- rtn <- true

  defines class
    CheckClass

      //First methodA
      methodA()
        ->
          arg0 as Integer
          arg1 as C2
        assert arg0? and arg1?

      //Second methodA
      methodA()
        ->
          arg0 as Integer
          arg1 as Integer
        assert arg0? and arg1?

      //Third methodA
      methodA()
        ->
          arg0 as C2
          arg1 as Integer
        assert arg0? and arg1?

      methodB()
        -> arg0 as Integer
        assert arg0?

  defines program

    TestProgram1()

      //The test variables for use with methodA.
      c1 <- C1()
      c2 <- C2()
      c3 <- C3()

      //Now the tests.
      checkClass <- CheckClass()

      //Obvious matches

      //Matches First methodA: Integer, C2
      checkClass.methodA(6, c2)
      //Matches First methodA: Integer, Integer
      checkClass.methodA(6, 18)

      //Now coercion enabling matches.

      //Matches First methodA: Integer, c3 #^ C2
      checkClass.methodA(6, c3)

      //Matches Second methodA: Integer, c1 #^ Integer
      checkClass.methodA(6, c1)

      //Matches Second methodA: Integer, c2 #^ Integer
      checkClass.methodA(6, c2)

      //Matches First methodA: c1 #^ Integer, C2
      checkClass.methodA(c1, c2)

      //Now multiple coercions

      //Matches Second methodA: c2 #^ Integer, c1 #^ Integer
      checkClass.methodA(c2, c1)

      //Matches First methodA: c1 #^ Integer, c3 #^ C2
      checkClass.methodA(c1, c3)

      //Now demonstration that only one coercion is applied

      //These are fine as only one coercion is required
      checkClass.methodB(c1)
      checkClass.methodB(c2)

      //So while C3 #^ C2 and C2 #^ Integer - EK9 only allows one coercion.
      @Error: FULL_RESOLUTION: METHOD_NOT_RESOLVED
      checkClass.methodB(c3)

      //TO solve this as a developer, do a promotion first
      //This will get to a C2 - which then C2 #^ Integer
      checkClass.methodB(#^c3)

      //Or even be explicit in the conversion yourself to Integer
      checkClass.methodB(#^#^c3)

      // Now a demonstration of how coercion can result in ambiguity.
      //As C2 can be coerced to Integer it can match:
      //Matches First methodA: c2 #^ Integer, C2
      //Matches Third methodA: C2, c2 #^ Integer
      //This results in an equal cost match.
      @Error: FULL_RESOLUTION: METHOD_AMBIGUOUS
      checkClass.methodA(c2, c2)

      //To resolve, just coerce before the call.
      checkClass.methodA(#^c2, c2)
      //Or
      checkClass.methodA(c2, #^c2)
      //Or
      checkClass.methodA(#^c2, #^c2)

//EOF