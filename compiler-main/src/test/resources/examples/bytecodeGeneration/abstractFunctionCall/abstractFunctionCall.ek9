#!ek9
<?-
  Bytecode test for abstract function calls.
  Verifies that:
  1. Abstract functions generate abstract classes (no INSTANCE)
  2. Concrete functions extending abstract have INSTANCE and working _call
  3. Program can call the concrete function
  4. Polymorphic usage (hold concrete via abstract type) works
-?>
defines module bytecode.test.abstractfunctioncall

  @BYTECODE: CODE_GENERATION_AGGREGATES: FUNCTION: "bytecode.test.abstractfunctioncall::baseGreeting": `public abstract class bytecode.test.abstractfunctioncall.baseGreeting {
  public abstract org.ek9.lang.String _call(org.ek9.lang.String);

  public bytecode.test.abstractfunctioncall.baseGreeting();
    Code:
         0: aload_0
         1: invokespecial #CP                 // Method java/lang/Object."<init>":()V
         4: aload_0
         5: invokevirtual #CP                 // Method i_init:()V
         8: return

  static {};
    Code:
         0: return

  private void i_init();
    Code:
         0: return
}`

  defines function

    // Abstract function - NO INSTANCE, NO getInstance(), abstract _call
    baseGreeting() as abstract
      -> name as String
      <- greeting as String?

    // Concrete implementation - HAS INSTANCE, getInstance(), concrete _call
    @BYTECODE: CODE_GENERATION_AGGREGATES: FUNCTION: "bytecode.test.abstractfunctioncall::helloGreeting": `public class bytecode.test.abstractfunctioncall.helloGreeting extends bytecode.test.abstractfunctioncall.baseGreeting

{
  private static final bytecode.test.abstractfunctioncall.helloGreeting INSTANCE;

  public static bytecode.test.abstractfunctioncall.helloGreeting getInstance();
    Code:
         0: getstatic     #CP                 // Field INSTANCE:Lbytecode/test/abstractfunctioncall/helloGreeting;
         3: areturn

  public org.ek9.lang.String _call(org.ek9.lang.String);
    Code:
         0: aconst_null
         1: astore_2
         2: ldc           #CP                 // String Hello,
         4: invokestatic  #CP                 // Method org/ek9/lang/String._of:(Ljava/lang/String;)Lorg/ek9/lang/String;
         7: astore_3
         8: aload_1
         9: astore        4
        11: aload_3
        12: aload         4
        14: invokevirtual #CP                 // Method org/ek9/lang/String._add:(Lorg/ek9/lang/String;)Lorg/ek9/lang/String;
        17: astore        5
        19: aload         5
        21: astore_2
        22: aload_2
        23: areturn

  public bytecode.test.abstractfunctioncall.helloGreeting();
    Code:
         0: aload_0
         1: invokespecial #CP                 // Method bytecode/test/abstractfunctioncall/baseGreeting."<init>":()V
         4: aload_0
         5: invokevirtual #CP                 // Method i_init:()V
         8: return

  static {};
    Code:
         0: new           #CP                  // class bytecode/test/abstractfunctioncall/helloGreeting
         3: dup
         4: invokespecial #CP                 // Method "<init>":()V
         7: putstatic     #CP                 // Field INSTANCE:Lbytecode/test/abstractfunctioncall/helloGreeting;
        10: return

  private void i_init();
    Code:
         0: return
}`
    helloGreeting() extends baseGreeting
      -> name as String
      <- greeting as String: "Hello, " + name

  defines program

    AbstractFunctionCall()
      -> arg as String
      stdout <- Stdout()

      // Call concrete function directly
      result <- helloGreeting(arg)
      stdout.println(result)

//EOF
