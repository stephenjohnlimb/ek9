#!ek9
defines module introduction1

  defines program

    @IR: IR_GENERATION: TYPE: "introduction1::HelloWorld": `
    ConstructDfn: introduction1::HelloWorld
    PROGRAM_ENTRY_POINT_BLOCK
    [
    programs_count: 4
    available_programs:
    [
    introduction1::HelloMessage
    [
    0:message:org.ek9.lang::String
    ]
    introduction1::HelloWorld
    introduction2::HelloEarth
    introduction2::HelloMars
    ]
    ]
    OperationDfn: introduction1::HelloWorld.c_init()->org.ek9.lang::Void
    BasicBlock: _entry_1
    RETURN
    OperationDfn: introduction1::HelloWorld.i_init()->org.ek9.lang::Void
    BasicBlock: _entry_1
    RETURN
    OperationDfn: introduction1::HelloWorld.HelloWorld()->introduction1::HelloWorld  // ./helloWorldIR.ek9:53:5
    BasicBlock: _entry_1
    _temp_i_init = CALL (introduction1::HelloWorld)this.i_init() [pure=false, complexity=0]  // ./helloWorldIR.ek9:53:5
    RETURN this  // ./helloWorldIR.ek9:53:5
    OperationDfn: introduction1::HelloWorld._main()->org.ek9.lang::Void  // ./helloWorldIR.ek9:53:5
    BasicBlock: _entry_2
    SCOPE_ENTER _scope_1  // ./helloWorldIR.ek9:55:7
    REFERENCE stdout, org.ek9.lang::Stdout  // ./helloWorldIR.ek9:55:7
    _temp1 = CALL (org.ek9.lang::Stdout)org.ek9.lang::Stdout.<init>() [pure=true, complexity=1, effects=IO,RETURN_MUTATION]  // ./helloWorldIR.ek9:55:17
    RETAIN _temp1  // ./helloWorldIR.ek9:55:17
    SCOPE_REGISTER _temp1, _scope_1  // ./helloWorldIR.ek9:55:17
    STORE stdout, _temp1  // ./helloWorldIR.ek9:55:17
    RETAIN stdout  // ./helloWorldIR.ek9:55:17
    SCOPE_REGISTER stdout, _scope_1  // ./helloWorldIR.ek9:55:17
    REFERENCE toOutput, org.ek9.lang::String  // ./helloWorldIR.ek9:56:7
    _temp2 = LOAD_LITERAL "Hello, World", org.ek9.lang::String  // ./helloWorldIR.ek9:56:19
    RETAIN _temp2  // ./helloWorldIR.ek9:56:19
    SCOPE_REGISTER _temp2, _scope_1  // ./helloWorldIR.ek9:56:19
    STORE toOutput, _temp2  // ./helloWorldIR.ek9:56:19
    RETAIN toOutput  // ./helloWorldIR.ek9:56:19
    SCOPE_REGISTER toOutput, _scope_1  // ./helloWorldIR.ek9:56:19
    _temp4 = LOAD stdout  // ./helloWorldIR.ek9:57:14
    _temp3 = CALL (org.ek9.lang::Stdout)_temp4.println(toOutput) [pure=false, complexity=0]  // ./helloWorldIR.ek9:57:14
    SCOPE_EXIT _scope_1  // ./helloWorldIR.ek9:55:7
    RETURN  // ./helloWorldIR.ek9:53:5`
    HelloWorld()

      stdout <- Stdout()
      toOutput <- "Hello, World"
      stdout.println(toOutput)

    @IR: IR_GENERATION: TYPE: "introduction1::HelloMessage": `
    ConstructDfn: introduction1::HelloMessage
    PROGRAM_ENTRY_POINT_BLOCK
    [
    programs_count: 4
    available_programs:
    [
    introduction1::HelloMessage
    [
    0:message:org.ek9.lang::String
    ]
    introduction1::HelloWorld
    introduction2::HelloEarth
    introduction2::HelloMars
    ]
    ]
    OperationDfn: introduction1::HelloMessage.c_init()->org.ek9.lang::Void
    BasicBlock: _entry_1
    RETURN
    OperationDfn: introduction1::HelloMessage.i_init()->org.ek9.lang::Void
    BasicBlock: _entry_1
    RETURN
    OperationDfn: introduction1::HelloMessage.HelloMessage()->introduction1::HelloMessage  // ./helloWorldIR.ek9:100:5
    BasicBlock: _entry_1
    _temp_i_init = CALL (introduction1::HelloMessage)this.i_init() [pure=false, complexity=0]  // ./helloWorldIR.ek9:100:5
    RETURN this  // ./helloWorldIR.ek9:100:5
    OperationDfn: introduction1::HelloMessage._main(org.ek9.lang::String)->org.ek9.lang::Void  // ./helloWorldIR.ek9:100:5
    BasicBlock: _entry_2
    REFERENCE message, org.ek9.lang::String  // ./helloWorldIR.ek9:101:10
    SCOPE_ENTER _scope_1  // ./helloWorldIR.ek9:103:7
    REFERENCE stdout, org.ek9.lang::Stdout  // ./helloWorldIR.ek9:103:7
    _temp1 = CALL (org.ek9.lang::Stdout)org.ek9.lang::Stdout.<init>() [pure=true, complexity=1, effects=IO,RETURN_MUTATION]  // ./helloWorldIR.ek9:103:17
    RETAIN _temp1  // ./helloWorldIR.ek9:103:17
    SCOPE_REGISTER _temp1, _scope_1  // ./helloWorldIR.ek9:103:17
    STORE stdout, _temp1  // ./helloWorldIR.ek9:103:17
    RETAIN stdout  // ./helloWorldIR.ek9:103:17
    SCOPE_REGISTER stdout, _scope_1  // ./helloWorldIR.ek9:103:17
    _temp3 = LOAD stdout  // ./helloWorldIR.ek9:104:14
    _temp2 = CALL (org.ek9.lang::Stdout)_temp3.println(message) [pure=false, complexity=0]  // ./helloWorldIR.ek9:104:14
    SCOPE_EXIT _scope_1  // ./helloWorldIR.ek9:103:7
    RETURN  // ./helloWorldIR.ek9:100:5`
    HelloMessage()
      -> message as String

      stdout <- Stdout()
      stdout.println(message)

//EOF