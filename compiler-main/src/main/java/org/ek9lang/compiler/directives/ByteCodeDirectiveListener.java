package org.ek9lang.compiler.directives;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.function.BiPredicate;
import org.ek9lang.compiler.backend.jvm.BytecodeNormalizer;
import org.ek9lang.compiler.common.CompilationEvent;
import org.ek9lang.compiler.support.LineByLineComparator;
import org.ek9lang.compiler.symbols.ISymbol;
import org.ek9lang.core.CompilerException;
import org.ek9lang.core.FileHandling;
import org.ek9lang.core.OsSupport;
import org.ek9lang.core.TargetArchitecture;

/**
 * Checks if there are any directives that relate to @BYTECODE in the parsed module and validates
 * the generated JVM bytecode against expected output.
 * Uses BytecodeNormalizer to produce stable, comparable bytecode representations.
 */
public class ByteCodeDirectiveListener extends ResolvedDirectiveListener {

  private final BiPredicate<String, String> lineComparator = new LineByLineComparator();
  private final FileHandling fileHandling = new FileHandling(new OsSupport());

  @Override
  public void accept(final CompilationEvent compilationEvent) {

    if (compilationEvent.parsedModule() != null) {
      //Only interested in BYTECODE directives for this phase.
      final var directives =
          compilationEvent.parsedModule().getDirectives(DirectiveType.BYTECODE, compilationEvent.phase());
      if (!directives.isEmpty()) {
        processDirectives(compilationEvent, directives);
      }
    }

  }

  @Override
  protected void symbolMatch(final CompilationEvent compilationEvent,
                             final ResolutionDirective resolutionDirective,
                             final ISymbol symbol) {

    //Check the types and the like.
    super.symbolMatch(compilationEvent, resolutionDirective, symbol);

    //Now locate the .class file for this symbol
    final File classFile = locateClassFile(compilationEvent, symbol);

    if (!classFile.exists()) {
      throw new CompilerException(
          "Class file not found for symbol: " + resolutionDirective.getSymbolName() + " at " + classFile);
    }

    //Read the bytecode from the .class file
    final byte[] classBytes;
    try {
      classBytes = Files.readAllBytes(classFile.toPath());
    } catch (IOException e) {
      throw new CompilerException("Failed to read class file: " + classFile, e);
    }

    //Normalize the bytecode using javap
    final String normalizedBytecode = BytecodeNormalizer.normalize(classBytes);

    //Compare with expected bytecode
    if (!lineComparator.test(resolutionDirective.getAdditionalName(), normalizedBytecode)) {
      System.err.println("Actual bytecode:");
      System.err.println(normalizedBytecode);
      throw new CompilerException("Expected bytecode and Generated bytecode differ");
    }

  }

  /**
   * Locate the .class file for a given symbol using the same logic as OutputFileAccess.
   * Tries both dev and main output directories.
   */
  private File locateClassFile(final CompilationEvent compilationEvent, final ISymbol symbol) {
    //Get the .ek9 directory
    final var sourceFile = compilationEvent.source().getFileName();
    final var projectDirectory = new File(sourceFile).getParent();
    final var projectDotEK9Directory = fileHandling.getDotEk9Directory(projectDirectory);

    //Convert symbol fully qualified name to JVM file path (with .class extension)
    //Converts "some.module.name::ConstructItem" to "some/module/name/ConstructItem.class"
    final var jvmName = symbol.getFullyQualifiedName().replace(".", "/").replace("::", "/");
    final var classFileName = jvmName + ".class";

    //Try dev build directory first
    File outputDir = fileHandling.getDevGeneratedOutputDirectory(projectDotEK9Directory, TargetArchitecture.JVM);
    File classFile = new File(outputDir, classFileName);
    if (classFile.exists()) {
      return classFile;
    }

    //Try main build directory
    outputDir = fileHandling.getMainGeneratedOutputDirectory(projectDotEK9Directory, TargetArchitecture.JVM);
    classFile = new File(outputDir, classFileName);
    if (classFile.exists()) {
      return classFile;
    }

    //Return the main directory path even if it doesn't exist (error handling in calling code)
    return classFile;
  }

}
