package org.ek9lang.compiler.phase7.generator;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;
import org.ek9lang.antlr.EK9Parser;
import org.ek9lang.compiler.common.OperatorMap;
import org.ek9lang.compiler.ir.data.ConditionCaseDetails;
import org.ek9lang.compiler.ir.data.ControlFlowChainDetails;
import org.ek9lang.compiler.ir.instructions.CallInstr;
import org.ek9lang.compiler.ir.instructions.IRInstr;
import org.ek9lang.compiler.ir.instructions.MemoryInstr;
import org.ek9lang.compiler.ir.instructions.ScopeInstr;
import org.ek9lang.compiler.phase7.calls.CallContext;
import org.ek9lang.compiler.phase7.generation.IRFrameType;
import org.ek9lang.compiler.phase7.generation.IRGenerationContext;
import org.ek9lang.compiler.phase7.support.ExprProcessingDetails;
import org.ek9lang.compiler.phase7.support.IRConstants;
import org.ek9lang.compiler.phase7.support.VariableDetails;
import org.ek9lang.compiler.symbols.CallSymbol;
import org.ek9lang.compiler.symbols.FunctionSymbol;
import org.ek9lang.compiler.symbols.ISymbol;
import org.ek9lang.compiler.symbols.MethodSymbol;
import org.ek9lang.core.AssertValue;
import org.ek9lang.core.CompilerException;

/**
 * Generates IR for for-range loops using CONTROL_FLOW_CHAIN.
 * Currently handles simple for-range loops (no BY clause, statement form only).
 * <p>
 * For-range loops are transformed into while loops with range state setup.
 * Uses temp variables for uniqueness in nested loops.
 * <p>
 * POLYMORPHIC DESIGN: Works with ANY type that implements required operators:
 * - Comparison operators (<=, >=, or <=>)
 * - ++ operator for increment (when no BY clause)
 * - -- operator for decrement (for descending ranges)
 * - += operator (when BY clause present)
 * <p>
 * Range type is obtained from resolved symbols, NOT hardcoded.
 * Supports Integer, Float, Date, Duration, and custom types.
 * </p>
 */
public final class ForStatementGenerator extends AbstractGenerator
    implements Function<EK9Parser.ForStatementExpressionContext, List<IRInstr>> {

  private final OperatorMap operatorMap = new OperatorMap();
  private final GeneratorSet generators;

  public ForStatementGenerator(final IRGenerationContext stackContext,
                                final GeneratorSet generators) {
    super(stackContext);
    AssertValue.checkNotNull("GeneratorSet cannot be null", generators);
    this.generators = generators;
  }

  @Override
  public List<IRInstr> apply(final EK9Parser.ForStatementExpressionContext ctx) {
    AssertValue.checkNotNull("ForStatementExpressionContext cannot be null", ctx);

    if (ctx.forLoop() != null) {
      throw new CompilerException("For-in loops not yet implemented");
    }

    if (ctx.returningParam() != null) {
      throw new CompilerException("For loop expression form not yet implemented");
    }

    return generateSimpleForRangeLoop(ctx);
  }

  private List<IRInstr> generateSimpleForRangeLoop(
      final EK9Parser.ForStatementExpressionContext ctx) {

    final var instructions = new ArrayList<IRInstr>();
    final var debugInfo = stackContext.createDebugInfo(ctx);
    final var forRangeCtx = ctx.forRange();

    if (forRangeCtx.preFlowStatement() != null) {
      throw new CompilerException("For loop guards not yet implemented");
    }

    if (forRangeCtx.BY() != null) {
      throw new CompilerException("For loop BY clause not yet implemented");
    }

    // RANGE SETUP: Evaluate start, end expressions in CURRENT scope
    // These temp variables registered outside loop to enable SSA phi generation for current

    // Get the range type from the resolved range expression symbol
    // This type is set by RangeOrError in Phase 3 as the common type of start/end expressions
    final var rangeSymbol = getRecordedSymbolOrException(forRangeCtx.range());
    final var rangeType = rangeSymbol.getType().orElseThrow(
        () -> new CompilerException("Range expression must have a type")
    );

    // Evaluate start expression -> temp variable
    final var startTemp = stackContext.generateTempName();
    final var startResult = createTempVariable(debugInfo);
    instructions.addAll(generators.exprGenerator.apply(
        new ExprProcessingDetails(forRangeCtx.range().expression(0), startResult)
    ));
    final var loadStartInstructions = new ArrayList<IRInstr>();
    loadStartInstructions.add(MemoryInstr.load(startTemp, startResult.resultVariable(), debugInfo));
    instructions.addAll(generators.variableMemoryManagement.apply(
        () -> loadStartInstructions,
        new VariableDetails(startTemp, debugInfo)
    ));

    // Evaluate end expression -> temp variable
    final var endTemp = stackContext.generateTempName();
    final var endResult = createTempVariable(debugInfo);
    instructions.addAll(generators.exprGenerator.apply(
        new ExprProcessingDetails(forRangeCtx.range().expression(1), endResult)
    ));
    final var loadEndInstructions = new ArrayList<IRInstr>();
    loadEndInstructions.add(MemoryInstr.load(endTemp, endResult.resultVariable(), debugInfo));
    instructions.addAll(generators.variableMemoryManagement.apply(
        () -> loadEndInstructions,
        new VariableDetails(endTemp, debugInfo)
    ));

    // Initialize current = start (will be updated via ++ operator in loop body)
    final var currentTemp = stackContext.generateTempName();
    final var initCurrentInstructions = new ArrayList<IRInstr>();
    initCurrentInstructions.add(MemoryInstr.load(currentTemp, startTemp, debugInfo));
    instructions.addAll(generators.variableMemoryManagement.apply(
        () -> initCurrentInstructions,
        new VariableDetails(currentTemp, debugInfo)
    ));

    // SCOPE 1: Enter loop outer scope (for future guards)
    final var outerScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    stackContext.enterScope(outerScopeId, debugInfo, IRFrameType.BLOCK);
    instructions.add(ScopeInstr.enter(outerScopeId, debugInfo));

    // SCOPE 2: Enter loop control scope
    final var loopControlScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    stackContext.enterScope(loopControlScopeId, debugInfo, IRFrameType.BLOCK);
    instructions.add(ScopeInstr.enter(loopControlScopeId, debugInfo));

    // SCOPE 3: Enter condition iteration scope
    final var conditionIterationScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    stackContext.enterScope(conditionIterationScopeId, debugInfo, IRFrameType.BLOCK);

    // Build condition: current <= end (using polymorphic <= operator from rangeType)
    final var conditionResult = createTempVariable(debugInfo);
    final var conditionEvaluation = new ArrayList<IRInstr>();
    conditionEvaluation.add(ScopeInstr.enter(conditionIterationScopeId, debugInfo));

    // Load current
    final var loadCurrentCond = stackContext.generateTempName();
    final var loadCurrentCondInstructions = new ArrayList<IRInstr>();
    loadCurrentCondInstructions.add(MemoryInstr.load(loadCurrentCond, currentTemp, debugInfo));
    conditionEvaluation.addAll(generators.variableMemoryManagement.apply(
        () -> loadCurrentCondInstructions,
        new VariableDetails(loadCurrentCond, debugInfo)
    ));

    // Load end
    final var loadEndCond = stackContext.generateTempName();
    final var loadEndCondInstructions = new ArrayList<IRInstr>();
    loadEndCondInstructions.add(MemoryInstr.load(loadEndCond, endTemp, debugInfo));
    conditionEvaluation.addAll(generators.variableMemoryManagement.apply(
        () -> loadEndCondInstructions,
        new VariableDetails(loadEndCond, debugInfo)
    ));

    // Use polymorphic <= operator - get method name from OperatorMap
    final var comparisonMethodName = operatorMap.getForward("<=");

    // Create call context for polymorphic comparison: current._lteq(end)
    final var comparisonCallContext = CallContext.forBinaryOperation(
        rangeType,                          // Target type (range type)
        rangeType,                          // Argument type (range type)
        null,                               // Return type resolved by callDetailsBuilder
        comparisonMethodName,               // Method name (_lteq from OperatorMap)
        loadCurrentCond,                    // Target variable (current)
        loadEndCond,                        // Argument variable (end)
        stackContext.currentScopeId()      // Current scope
    );

    // Use callDetailsBuilder for cost-based resolution and promotion
    final var comparisonCallResult = generators.callDetailsBuilder.apply(comparisonCallContext);
    conditionEvaluation.addAll(comparisonCallResult.allInstructions());

    // Generate the comparison operator call
    conditionEvaluation.add(CallInstr.operator(
        conditionResult.resultVariable(),
        debugInfo,
        comparisonCallResult.callDetails()
    ));

    // Convert to primitive boolean
    final var conversion = convertToPrimitiveBoolean(conditionResult.resultVariable(), debugInfo);
    final var primitiveCondition = conversion.addToInstructions(conditionEvaluation);

    conditionEvaluation.add(ScopeInstr.exit(conditionIterationScopeId, debugInfo));
    stackContext.exitScope();

    // SCOPE 4: Enter body iteration scope
    final var bodyIterationScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    stackContext.enterScope(bodyIterationScopeId, debugInfo, IRFrameType.BLOCK);

    // Build body
    final var bodyEvaluation = new ArrayList<IRInstr>();
    bodyEvaluation.add(ScopeInstr.enter(bodyIterationScopeId, debugInfo));

    // Loop variable binding: loopVar = current
    final var loopVarName = forRangeCtx.identifier().getFirst().getText();
    final var loadCurrentBody = stackContext.generateTempName();
    final var loadCurrentBodyInstructions = new ArrayList<IRInstr>();
    loadCurrentBodyInstructions.add(MemoryInstr.load(loadCurrentBody, currentTemp, debugInfo));
    bodyEvaluation.addAll(generators.variableMemoryManagement.apply(
        () -> loadCurrentBodyInstructions,
        new VariableDetails(loadCurrentBody, debugInfo)
    ));
    bodyEvaluation.add(MemoryInstr.store(loopVarName, loadCurrentBody, debugInfo));
    bodyEvaluation.add(MemoryInstr.retain(loopVarName, debugInfo));
    bodyEvaluation.add(ScopeInstr.register(loopVarName, bodyIterationScopeId, debugInfo));

    // User body statements
    bodyEvaluation.addAll(processBlockStatements(ctx.instructionBlock()));

    // Increment: current = current++ (using polymorphic ++ operator)
    // Phase 1: No BY clause, so use ++ operator validated by ForRangeOrError
    final var loadCurrentInc = stackContext.generateTempName();
    final var loadCurrentIncInstructions = new ArrayList<IRInstr>();
    loadCurrentIncInstructions.add(MemoryInstr.load(loadCurrentInc, currentTemp, debugInfo));
    bodyEvaluation.addAll(generators.variableMemoryManagement.apply(
        () -> loadCurrentIncInstructions,
        new VariableDetails(loadCurrentInc, debugInfo)
    ));

    // Use polymorphic ++ operator - get method name from OperatorMap
    final var incrementMethodName = operatorMap.getForward("++");  // Returns "_inc"

    final var incResult = createTempVariable(debugInfo);

    // Create call context for polymorphic increment: current._inc()
    final var incrementCallContext = CallContext.forUnaryOperation(
        rangeType,                          // Target type (range type)
        incrementMethodName,                // Method name (_inc from OperatorMap)
        loadCurrentInc,                     // Target variable (current)
        rangeType,                          // Return type (same as range type)
        stackContext.currentScopeId()      // Current scope
    );

    // Use callDetailsBuilder for cost-based resolution
    final var incrementCallResult = generators.callDetailsBuilder.apply(incrementCallContext);
    bodyEvaluation.addAll(incrementCallResult.allInstructions());

    // Generate the increment operator call
    bodyEvaluation.add(CallInstr.operator(
        incResult.resultVariable(),
        debugInfo,
        incrementCallResult.callDetails()
    ));

    // Store back to current (REASSIGNMENT)
    bodyEvaluation.add(MemoryInstr.release(currentTemp, debugInfo));
    bodyEvaluation.add(MemoryInstr.store(currentTemp, incResult.resultVariable(), debugInfo));
    bodyEvaluation.add(MemoryInstr.retain(currentTemp, debugInfo));

    bodyEvaluation.add(ScopeInstr.exit(bodyIterationScopeId, debugInfo));
    stackContext.exitScope();

    // Create ConditionCaseDetails
    final var conditionCase = ConditionCaseDetails.createExpression(
        conditionIterationScopeId,
        conditionEvaluation,
        conditionResult.resultVariable(),
        primitiveCondition,
        bodyEvaluation,
        null
    );

    // Create CONTROL_FLOW_CHAIN
    final var forRangeDetails = ControlFlowChainDetails.createForRangeLoop(
        List.of(conditionCase),
        debugInfo,
        loopControlScopeId
    );

    instructions.addAll(generators.controlFlowChainGenerator.apply(forRangeDetails));

    // Exit scopes
    instructions.add(ScopeInstr.exit(loopControlScopeId, debugInfo));
    stackContext.exitScope();

    instructions.add(ScopeInstr.exit(outerScopeId, debugInfo));
    stackContext.exitScope();

    return instructions;
  }

  private List<IRInstr> processBlockStatements(final EK9Parser.InstructionBlockContext ctx) {
    final var instructions = new ArrayList<IRInstr>();
    for (var blockStatement : ctx.blockStatement()) {
      instructions.addAll(generators.blockStmtGenerator.apply(blockStatement));
    }
    return instructions;
  }
}
