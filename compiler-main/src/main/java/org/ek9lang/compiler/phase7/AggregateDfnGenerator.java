package org.ek9lang.compiler.phase7;

import org.ek9lang.antlr.EK9Parser;
import org.ek9lang.compiler.ir.instructions.IRConstruct;
import org.ek9lang.compiler.ir.instructions.OperationInstr;
import org.ek9lang.compiler.phase7.generation.IRGenerationContext;
import org.ek9lang.compiler.phase7.generation.IRInstructionBuilder;
import org.ek9lang.compiler.phase7.support.FieldCreator;
import org.ek9lang.compiler.phase7.support.FieldsFromCapture;
import org.ek9lang.compiler.phase7.support.IRConstants;
import org.ek9lang.compiler.phase7.support.OperationDetailContextOrError;
import org.ek9lang.compiler.symbols.AggregateSymbol;
import org.ek9lang.compiler.symbols.IScopedSymbol;
import org.ek9lang.compiler.symbols.ISymbol;
import org.ek9lang.compiler.symbols.MethodSymbol;
import org.ek9lang.compiler.symbols.SymbolGenus;
import org.ek9lang.core.AssertValue;
import org.ek9lang.core.CompilerException;

/**
 * Common code of Aggregate Construct types.
 */
abstract class AggregateDfnGenerator extends AbstractDfnGenerator {

  private final OperationDetailContextOrError operationDetailContextOrError;

  private final SymbolGenus expectedGenus;

  AggregateDfnGenerator(final IRGenerationContext stackContext, final SymbolGenus forGenus) {
    super(stackContext);
    this.operationDetailContextOrError = new OperationDetailContextOrError(stackContext.getParsedModule());
    this.expectedGenus = forGenus;
  }

  protected IRConstruct processAggregate(final AggregateSymbol aggregateSymbol,
                                         final EK9Parser.AggregatePartsContext ctx) {

    AssertValue.checkTrue("Only configured for " + expectedGenus,
        expectedGenus == aggregateSymbol.getGenus());

    final var construct = new IRConstruct(aggregateSymbol);

    // Create field declarations from symbol table
    createFieldDeclarations(construct, aggregateSymbol);

    // Create three-phase initialization operations
    createInitializationOperations(construct, aggregateSymbol, ctx);

    // Process aggregateParts if present (methods, operators)
    if (ctx != null) {
      createOperationsForAggregateParts(construct, aggregateSymbol, ctx);
    }

    return construct;
  }

  /**
   * Create field declarations using AggregateSymbol.getProperties().
   * This provides structural metadata about the class's data members,
   * separate from the behavioral operations (methods).
   */
  protected void createFieldDeclarations(final IRConstruct construct, final AggregateSymbol aggregateSymbol) {

    final var debugInfoCreator = createDebugInfoCreator();
    final var fieldCreator = new FieldCreator(construct, debugInfoCreator);
    final var fieldsFromCapture = new FieldsFromCapture(fieldCreator);

    aggregateSymbol.getProperties().forEach(fieldCreator);
    fieldsFromCapture.accept(aggregateSymbol);
  }

  /**
   * Create the three-phase initialization operations for the class:
   * 1. c_init - Class/static initialization
   * 2. i_init - Instance initialization (property declarations and immediate initialization)
   * 3. Constructor methods will be processed separately in createOperationsForAggregateParts
   */
  protected void createInitializationOperations(final IRConstruct construct,
                                                final AggregateSymbol aggregateSymbol,
                                                final EK9Parser.AggregatePartsContext ctx) {

    // Create c_init operation for class/static initialization
    final ISymbol superType = aggregateSymbol.getSuperAggregate().orElse(null);
    createInitOperation(construct, aggregateSymbol, superType);

    //Now the i_init operation for the instance when created.
    createInstanceInitOperation(construct, aggregateSymbol, ctx);

  }

  protected void createOperationsForAggregateParts(final IRConstruct construct,
                                                   final AggregateSymbol aggregateSymbol,
                                                   final EK9Parser.AggregatePartsContext ctx) {

    // Properties are now handled in i_init operation - no processing needed here

    // Process ALL methods from symbol table (explicit + synthetic)
    final var allMethods = aggregateSymbol.getAllMethodInThisScopeOnly();

    if (allMethods.isEmpty()) {
      throw new CompilerException("No methods found for class "
          + aggregateSymbol.getFullyQualifiedName() + " - earlier phases may have failed");
    }

    for (final var method : allMethods) {
      if (method.isSynthetic()) {
        processSyntheticMethod(construct, method);
      } else {
        processExplicitMethod(construct, method, ctx);
      }
    }
  }

  /**
   * Process a synthetic method (generated by earlier compiler phases).
   * These include synthetic constructors, operators from 'default operator', and other generated methods.
   */
  private void processSyntheticMethod(final IRConstruct construct, final MethodSymbol method) {
    if (method.isConstructor()) {
      // Synthetic default constructor
      final var aggregateSymbol = (AggregateSymbol) method.getParentScope();
      final IScopedSymbol superType = aggregateSymbol.getSuperAggregate().orElse(null);
      processSyntheticConstructor(construct, method, superType);
    } else if (method.isOperator()) {
      // Synthetic operators from default operator
      processSyntheticOperator(construct, method);
    } else {
      // Synthetic regular methods (e.g., _isSet, _hash)
      processSyntheticRegularMethod(construct, method);
    }
  }

  /**
   * Process an explicit method (defined in source code with parse context).
   */
  private void processExplicitMethod(final IRConstruct construct, final MethodSymbol method,
                                     final EK9Parser.AggregatePartsContext ctx) {

    // Find the corresponding parse context for this method
    final var operationCtx = operationDetailContextOrError.apply(method, ctx);
    processAsMethodOrOperator(construct, method, operationCtx);

  }

  /**
   * Process a synthetic operator (generated from 'default operator' declarations).
   * For now, creates placeholder - full implementation will be added later.
   */
  private void processSyntheticOperator(final IRConstruct construct, final MethodSymbol operatorSymbol) {
    final var debugInfo = stackContext.createDebugInfo(operatorSymbol.getSourceToken());
    final var operation = new OperationInstr(operatorSymbol, debugInfo);

    // Generate placeholder body using stack-based instruction builder  
    var instructionBuilder = new IRInstructionBuilder(stackContext);

    // TODO: Implement based on operator type and base operators
    // This will be complex and handled in later implementation phases
    instructionBuilder.returnVoid(); // Placeholder

    operation.setBody(instructionBuilder.createBasicBlock(IRConstants.ENTRY_LABEL));

    construct.add(operation);
  }

  /**
   * Process a synthetic regular method (e.g., _isSet, _hash generated from properties).
   * For now, creates placeholder - full implementation will be added later.
   */
  private void processSyntheticRegularMethod(final IRConstruct construct, final MethodSymbol methodSymbol) {
    final var debugInfo = stackContext.createDebugInfo(methodSymbol.getSourceToken());
    final var operation = new OperationInstr(methodSymbol, debugInfo);

    // Generate placeholder body using stack-based instruction builder
    var instructionBuilder = new IRInstructionBuilder(stackContext);

    // TODO: Implement based on method semantics (e.g., _isSet, _hash)
    instructionBuilder.returnVoid(); // Placeholder

    operation.setBody(instructionBuilder.createBasicBlock(IRConstants.ENTRY_LABEL));

    construct.add(operation);
  }

}
