package org.ek9lang.compiler.phase7.generator;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;
import org.ek9lang.compiler.ir.data.CallDetails;
import org.ek9lang.compiler.ir.data.CallMetaDataDetails;
import org.ek9lang.compiler.ir.data.ConditionCaseDetails;
import org.ek9lang.compiler.ir.data.ControlFlowChainDetails;
import org.ek9lang.compiler.ir.data.DefaultCaseDetails;
import org.ek9lang.compiler.ir.data.EvaluationVariableDetails;
import org.ek9lang.compiler.ir.data.GuardVariableDetails;
import org.ek9lang.compiler.ir.data.ReturnVariableDetails;
import org.ek9lang.compiler.ir.instructions.CallInstr;
import org.ek9lang.compiler.ir.instructions.ControlFlowChainInstr;
import org.ek9lang.compiler.ir.instructions.IRInstr;
import org.ek9lang.compiler.ir.instructions.MemoryInstr;
import org.ek9lang.compiler.ir.instructions.ScopeInstr;
import org.ek9lang.compiler.ir.support.DebugInfo;
import org.ek9lang.compiler.phase7.calls.BooleanNotCallDetailsCreator;
import org.ek9lang.compiler.phase7.calls.CallDetailsForIsFalse;
import org.ek9lang.compiler.phase7.calls.CallDetailsForIsTrue;
import org.ek9lang.compiler.phase7.calls.CallDetailsForOfFalse;
import org.ek9lang.compiler.phase7.calls.IsSetCallDetailsCreator;
import org.ek9lang.compiler.phase7.generation.IRFrameType;
import org.ek9lang.compiler.phase7.generation.IRGenerationContext;
import org.ek9lang.compiler.phase7.support.BooleanFalseEvaluationCreator;
import org.ek9lang.compiler.phase7.support.BooleanNotEvaluationCreator;
import org.ek9lang.compiler.phase7.support.ExprProcessingDetails;
import org.ek9lang.compiler.phase7.support.IRConstants;
import org.ek9lang.compiler.phase7.support.IsSetEvaluationCreator;
import org.ek9lang.compiler.phase7.support.VariableDetails;
import org.ek9lang.compiler.phase7.support.VariableMemoryManagement;
import org.ek9lang.compiler.symbols.ISymbol;

/**
 * Unified IR generator for EK9 control flow operators using CONTROL_FLOW_CHAIN.
 * <p>
 * Supported Operators:
 * </p>
 * <ul>
 *   <li>Question operator (?) - null/set checking</li>
 *   <li>Guarded assignment (:=?) - conditional assignment</li>
 *   <li>Null coalescing operator (??) - returns LHS if allocated, else RHS</li>
 *   <li>Elvis coalescing operator (:?) - returns LHS if allocated AND set, else RHS</li>
 *   <li>Comparison coalescing operators ({@code <?, >?, <=?, >=?}) - safe comparison with null/unset handling</li>
 * </ul>
 * <p>
 * Key architectural benefits:<br>
 * - Single source of truth for operator control flow logic<br>
 * - Consistent memory management patterns across all operators<br>
 * - Unified optimization metadata for backend code generation<br>
 * - Reduced code duplication and maintenance burden<br>
 * </p>
 * <p>
 * NOTE: If/else, switch, while, do-while, for, and try/catch statements have their own
 * dedicated IR generators and are NOT generated by this class.
 * </p>
 */
public final class ControlFlowChainGenerator extends AbstractGenerator
    implements Function<ControlFlowChainDetails, List<IRInstr>> {

  private final Function<ExprProcessingDetails, List<IRInstr>> rawExprProcessor;
  private final VariableMemoryManagement variableMemoryManagement;
  private final CallDetailsForIsTrue callDetailsForIsTrue = new CallDetailsForIsTrue();

  // Helper classes for evaluation patterns
  private final BooleanFalseEvaluationCreator booleanFalseEvaluationCreator;
  private final IsSetEvaluationCreator isSetEvaluationCreator;
  private final BooleanNotEvaluationCreator booleanNotEvaluationCreator;

  public ControlFlowChainGenerator(final IRGenerationContext stackContext,
                                   final VariableMemoryManagement variableMemoryManagement,
                                   final Function<ExprProcessingDetails, List<IRInstr>> rawExprProcessor) {
    super(stackContext);
    this.rawExprProcessor = rawExprProcessor;
    this.variableMemoryManagement = variableMemoryManagement;

    final var callDetailsForOfFalse = new CallDetailsForOfFalse();
    final var isSetCallDetailsCreator = new IsSetCallDetailsCreator();
    final var booleanNotCallDetailsCreator = new BooleanNotCallDetailsCreator();

    // Initialize helper classes with injected VariableMemoryManagement
    this.booleanFalseEvaluationCreator = new BooleanFalseEvaluationCreator(
        callDetailsForOfFalse, variableMemoryManagement);
    this.isSetEvaluationCreator = new IsSetEvaluationCreator(
        isSetCallDetailsCreator, variableMemoryManagement);
    this.booleanNotEvaluationCreator = new BooleanNotEvaluationCreator(
        booleanNotCallDetailsCreator, variableMemoryManagement);
  }

  @Override
  public List<IRInstr> apply(final ControlFlowChainDetails details) {
    final var instructions = new ArrayList<IRInstr>();

    // Add guard scope management if needed
    if (details.hasGuardScope()) {
      instructions.add(ScopeInstr.enter(details.guardScopeId(), details.debugInfo()));
      instructions.addAll(details.guardScopeSetup());
    }

    // Add shared condition scope management if needed
    if (details.hasSharedConditionScope()) {
      instructions.add(ScopeInstr.enter(details.conditionScopeId(), details.debugInfo()));
    }

    // Add the main CONTROL_FLOW_CHAIN instruction
    final var controlFlowChain = ControlFlowChainInstr.controlFlowChain(details);
    instructions.add(controlFlowChain);

    // Close shared condition scope if opened
    if (details.hasSharedConditionScope()) {
      instructions.add(ScopeInstr.exit(details.conditionScopeId(), details.debugInfo()));
    }

    // Close guard scope if opened
    if (details.hasGuardScope()) {
      instructions.add(ScopeInstr.exit(details.guardScopeId(), details.debugInfo()));
    }

    return instructions;
  }

  /**
   * Generate SWITCH_CHAIN_BLOCK for Question operator (?).
   * Converts "operand?" to a two-case chain: null check + _isSet() default.
   * Question operator is self-contained - no RETAIN/SCOPE_REGISTER needed on input.
   */
  public List<IRInstr> generateQuestionOperator(final ExprProcessingDetails exprDetails) {
    final var ctx = exprDetails.ctx();
    final var resultVariable = exprDetails.variableDetails().resultVariable();

    // Get debug information from expression symbol
    final var exprSymbol = getRecordedSymbolOrException(ctx);
    final var debugInfo = debugInfoCreator.apply(exprSymbol.getSourceToken());
    // STACK-BASED: Get scope ID from current stack frame 
    final var scopeId = stackContext.currentScopeId();

    // Generate operand evaluation WITHOUT memory management (question operator is self-contained)
    final var operandVariable = stackContext.generateTempName();
    final var operandVariableDetails = new VariableDetails(operandVariable, debugInfo);

    // Use raw processor to avoid automatic RETAIN/SCOPE_REGISTER on operand
    final var operandEvaluationInstructions = new ArrayList<>(
        rawExprProcessor.apply(new ExprProcessingDetails(ctx.expression(0), operandVariableDetails)));

    // Add explicit IS_NULL check directly on operand (no memory management needed)
    final var nullCheckCondition = stackContext.generateTempName();
    operandEvaluationInstructions.add(MemoryInstr.isNull(nullCheckCondition, operandVariable, debugInfo));

    final var nullCaseResult = stackContext.generateTempName();
    final var nullCaseDetails = new VariableDetails(nullCaseResult, debugInfo);
    final var nullCaseEvaluation = generateBooleanFalseEvaluation(nullCaseDetails);

    final var nullCheckCase = ConditionCaseDetails.createNullCheck(
        stackContext.currentScopeId(), // STACK-BASED: Get scope ID from current stack frame
        operandEvaluationInstructions,
        null, // No EK9 Boolean condition result for null check
        nullCheckCondition, // primitive boolean condition
        nullCaseEvaluation,
        nullCaseResult
    );

    // Create default case: else return operand._isSet()
    // Only the _isSet() result needs memory management, not the operand
    final var setCaseResult = stackContext.generateTempName();
    final var setCaseDetails = new VariableDetails(setCaseResult, debugInfo);
    // IMPORTANT: Use operand's type (from ctx.expression(0)), not result type (exprSymbol is Boolean)
    final var operandType = typeNameOrException.apply(getRecordedSymbolOrException(ctx.expression(0)));
    final var setCaseEvaluation = generateIsSetEvaluationNoOperandManagement(operandVariable,
        operandType, setCaseDetails);

    // Create the unified switch chain details
    final var controlFlowChainDetails = ControlFlowChainDetails.createQuestionOperator(
        resultVariable,
        List.of(nullCheckCase),
        setCaseEvaluation,
        setCaseResult,
        debugInfo,
        scopeId
    );

    return apply(controlFlowChainDetails);
  }

  /**
   * Generate SWITCH_CHAIN_BLOCK for Question operator applied to a variable.
   * Used by guarded assignment composition.
   */
  public List<IRInstr> generateQuestionOperatorForVariable(final ISymbol variableSymbol,
                                                           final String resultVariable,
                                                           final DebugInfo debugInfo) {
    // STACK-BASED: Get scope ID from current stack frame
    final var scopeId = stackContext.currentScopeId();

    // Direct null check on variable - no LOAD/RETAIN/SCOPE_REGISTER needed for null checking
    final var operandEvaluationInstructions = new ArrayList<IRInstr>();

    // Add explicit IS_NULL check directly on the variable
    final var nullCheckCondition = stackContext.generateTempName();
    operandEvaluationInstructions.add(
        MemoryInstr.isNull(nullCheckCondition, variableSymbol.getName(), debugInfo));

    final var nullCaseResult = stackContext.generateTempName();
    final var nullCaseDetails = new VariableDetails(nullCaseResult, debugInfo);
    final var nullCaseEvaluation = generateBooleanFalseEvaluation(nullCaseDetails);

    final var nullCheckCase = ConditionCaseDetails.createNullCheck(
        stackContext.currentScopeId(), // STACK-BASED: Get scope ID from current stack frame
        operandEvaluationInstructions,
        null, // No EK9 Boolean condition result
        nullCheckCondition,
        nullCaseEvaluation,
        nullCaseResult
    );

    // Create default case: else return variable._isSet()
    // Need to load variable for _isSet() method call (but not for null check)
    final var operandVariable = stackContext.generateTempName();
    final var operandDetails = new VariableDetails(operandVariable, debugInfo);

    final var setCaseResult = stackContext.generateTempName();
    final var setCaseDetails = new VariableDetails(setCaseResult, debugInfo);
    final var setCaseEvaluation = generateIsSetEvaluationForVariable(variableSymbol.getName(),
        operandVariable, operandDetails, typeNameOrException.apply(variableSymbol), setCaseDetails);

    // Create the unified switch chain details
    final var controlFlowChainDetails = ControlFlowChainDetails.createQuestionOperator(
        resultVariable,
        List.of(nullCheckCase),
        setCaseEvaluation,
        setCaseResult,
        debugInfo,
        scopeId
    );

    return apply(controlFlowChainDetails);
  }

  /**
   * Generate SWITCH_CHAIN_BLOCK for guarded assignment (:=?).
   * Composes question operator logic: assign only if LHS is null OR !LHS._isSet().
   */
  public List<IRInstr> generateGuardedAssignment(final ISymbol lhsSymbol,
                                                 final List<IRInstr> assignmentEvaluation,
                                                 final String assignmentResult,
                                                 final DebugInfo debugInfo) {

    // STACK-BASED: Get scope ID from current stack frame
    final var scopeId = stackContext.currentScopeId();

    // Generate question operator for condition: lhsSymbol?
    final var conditionResult = stackContext.generateTempName();
    final var questionOperatorInstructions = generateQuestionOperatorForVariable(
        lhsSymbol, conditionResult, debugInfo);

    // Invert the condition: assign when NOT set (when question operator returns false)
    final var invertedCondition = stackContext.generateTempName();
    final var invertedConditionDetails = new VariableDetails(invertedCondition, debugInfo);
    final var inversionInstructions = generateBooleanNotEvaluation(conditionResult, invertedConditionDetails);

    // Create the condition evaluation that includes question operator + inversion
    final var conditionEvaluationInstructions = new ArrayList<IRInstr>();
    conditionEvaluationInstructions.addAll(questionOperatorInstructions);
    conditionEvaluationInstructions.addAll(inversionInstructions);

    // Get primitive condition for backend optimization
    final var primitiveCondition = stackContext.generateTempName();

    conditionEvaluationInstructions.add(CallInstr.operator(
        new VariableDetails(primitiveCondition, debugInfo),
        callDetailsForIsTrue.apply(invertedCondition)
    ));

    final var assignmentCase = ConditionCaseDetails.createExpression(
        stackContext.currentScopeId(), // STACK-BASED: Get scope ID from current stack frame
        conditionEvaluationInstructions,
        invertedCondition, // EK9 Boolean result  
        primitiveCondition, // primitive boolean for backends
        assignmentEvaluation,
        assignmentResult
    );

    // No default case - guarded assignment either assigns or does nothing
    final var controlFlowChainDetails = new ControlFlowChainDetails(
        null, // No overall result
        "GUARDED_ASSIGNMENT", // Special chain type
        GuardVariableDetails.none(), // No guard variables (guarded assignment handles this internally)
        EvaluationVariableDetails.none(), // No evaluation variable
        ReturnVariableDetails.none(), // No return variable
        List.of(assignmentCase),
        DefaultCaseDetails.none(), // No default case
        null, // No enum optimization
        null, // No try block
        List.of(), // No finally block
        debugInfo,
        scopeId
    );

    return apply(controlFlowChainDetails);
  }

  /**
   * Generate CONTROL_FLOW_CHAIN for Null Coalescing operator (??).
   * Returns LHS if memory allocated (even if unset), else evaluates and returns RHS.
   * <p>
   * IR Structure: 1 case + default<br>
   * Case 1: NULL_CHECK - if LHS is null → evaluate and return RHS<br>
   * Default: LHS not null → return LHS (even if unset)<br>
   * </p>
   */
  public List<IRInstr> generateNullCoalescing(final ExprProcessingDetails lhsDetails,
                                              final ExprProcessingDetails rhsDetails) {
    final var resultVariable = lhsDetails.variableDetails().resultVariable();
    final var debugInfo = lhsDetails.variableDetails().debugInfo();

    // Create dedicated scope for null coalescing operator
    final var coalesceScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    stackContext.enterScope(coalesceScopeId, debugInfo, IRFrameType.BLOCK);

    final var instructions = new ArrayList<IRInstr>();
    instructions.add(ScopeInstr.enter(coalesceScopeId, debugInfo));

    // Generate LHS evaluation - result stored in temp
    final var lhsTemp = stackContext.generateTempName();
    final var lhsTempDetails = new VariableDetails(lhsTemp, debugInfo);
    final var lhsProcessingDetails = new ExprProcessingDetails(lhsDetails.ctx().left, lhsTempDetails);
    final var lhsEvaluationInstructions = new ArrayList<>(rawExprProcessor.apply(lhsProcessingDetails));

    // Add IS_NULL check on LHS
    final var nullCheckCondition = stackContext.generateTempName();
    lhsEvaluationInstructions.add(MemoryInstr.isNull(nullCheckCondition, lhsTemp, debugInfo));

    // Create null check case: if LHS is null → evaluate RHS
    final var rhsTemp = stackContext.generateTempName();
    final var rhsTempDetails = new VariableDetails(rhsTemp, debugInfo);
    final var rhsProcessingDetails = new ExprProcessingDetails(rhsDetails.ctx().right, rhsTempDetails);
    // Wrap RHS evaluation with memory management for proper ARC (RETAIN + SCOPE_REGISTER)
    final var rhsEvaluationInstructions = variableMemoryManagement.apply(
        () -> rawExprProcessor.apply(rhsProcessingDetails),
        rhsTempDetails
    );

    // Generate unique scope for the NULL_CHECK case
    final var nullCheckScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    final var nullCheckCase = ConditionCaseDetails.createNullCheck(
        nullCheckScopeId,
        lhsEvaluationInstructions,
        null, // No EK9 Boolean condition result for null check
        nullCheckCondition, // primitive boolean condition
        rhsEvaluationInstructions,
        rhsTemp
    );

    // Create default case: LHS not null → return LHS (no additional evaluation needed)
    final var defaultBodyEvaluation = List.<IRInstr>of(); // LHS already evaluated

    // Create the null coalescing chain details
    final var controlFlowChainDetails = ControlFlowChainDetails.createNullCoalescing(
        resultVariable,
        List.of(nullCheckCase),
        defaultBodyEvaluation,
        lhsTemp,
        debugInfo,
        coalesceScopeId
    );

    instructions.addAll(apply(controlFlowChainDetails));

    instructions.add(ScopeInstr.exit(coalesceScopeId, debugInfo));
    stackContext.exitScope();

    return instructions;
  }

  /**
   * Generate CONTROL_FLOW_CHAIN for Elvis Coalescing operator (:?).
   * Returns LHS if memory allocated AND set, else evaluates and returns RHS.
   * <p>
   * IR Structure: 2 cases + default<br>
   * Case 1: NULL_CHECK - if LHS is null → evaluate and return RHS<br>
   * Case 2: IS_SET check - if LHS is not set → evaluate and return RHS<br>
   * Default: LHS is set → return LHS<br>
   * </p>
   * <p>
   * Safety: NULL_CHECK always precedes _isSet() call to prevent accessing unallocated memory.
   * </p>
   */
  public List<IRInstr> generateElvisCoalescing(final ExprProcessingDetails lhsDetails,
                                               final ExprProcessingDetails rhsDetails) {
    final var resultVariable = lhsDetails.variableDetails().resultVariable();
    final var debugInfo = lhsDetails.variableDetails().debugInfo();

    // Create dedicated scope for Elvis coalescing operator
    final var coalesceScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    stackContext.enterScope(coalesceScopeId, debugInfo, IRFrameType.BLOCK);

    final var instructions = new ArrayList<IRInstr>();
    instructions.add(ScopeInstr.enter(coalesceScopeId, debugInfo));

    // Generate LHS evaluation - result stored in temp
    final var lhsTemp = stackContext.generateTempName();
    final var lhsTempDetails = new VariableDetails(lhsTemp, debugInfo);
    final var lhsProcessingDetails = new ExprProcessingDetails(lhsDetails.ctx().left, lhsTempDetails);
    final var lhsEvaluationInstructions = new ArrayList<>(rawExprProcessor.apply(lhsProcessingDetails));

    // Add IS_NULL check on LHS
    final var nullCheckCondition = stackContext.generateTempName();
    lhsEvaluationInstructions.add(MemoryInstr.isNull(nullCheckCondition, lhsTemp, debugInfo));

    // Create RHS evaluation instructions (shared by both cases)
    final var rhsTemp = stackContext.generateTempName();
    final var rhsTempDetails = new VariableDetails(rhsTemp, debugInfo);
    final var rhsProcessingDetails = new ExprProcessingDetails(rhsDetails.ctx().right, rhsTempDetails);
    // Wrap RHS evaluation with memory management for proper ARC (RETAIN + SCOPE_REGISTER)
    final var rhsEvaluationInstructions = variableMemoryManagement.apply(
        () -> rawExprProcessor.apply(rhsProcessingDetails),
        rhsTempDetails
    );

    // Case 1: NULL_CHECK - if LHS is null → evaluate RHS
    final var nullCheckScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    final var nullCheckCase = ConditionCaseDetails.createNullCheck(
        nullCheckScopeId,
        lhsEvaluationInstructions,
        null, // No EK9 Boolean condition result for null check
        nullCheckCondition, // primitive boolean condition
        rhsEvaluationInstructions,
        rhsTemp
    );

    // Case 2: IS_SET check - if LHS is NOT set → evaluate RHS
    // Safe to call _isSet() here because null check passed
    final var isSetResultTemp = stackContext.generateTempName();
    final var isSetResultDetails = new VariableDetails(isSetResultTemp, debugInfo);

    // Get LHS type for _isSet() call
    final var lhsType = typeNameOrException.apply(getRecordedSymbolOrException(lhsDetails.ctx().left));

    // Call _isSet() on LHS using helper (includes memory management)
    final var isSetCheckInstructions =
        new ArrayList<>(isSetEvaluationCreator.apply(lhsTemp, lhsType, isSetResultDetails));

    // Extract inverted primitive: if NOT set (use ._false() instead of ._negate()._true())
    final var invertedPrimitiveTemp = stackContext.generateTempName();
    final var callDetailsForIsFalse = new CallDetailsForIsFalse();
    isSetCheckInstructions.add(CallInstr.operator(
        new VariableDetails(invertedPrimitiveTemp, debugInfo),
        callDetailsForIsFalse.apply(isSetResultTemp)
    ));

    final var isSetCheckScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    final var isSetCheckCase = ConditionCaseDetails.createExpression(
        isSetCheckScopeId,
        isSetCheckInstructions,
        isSetResultTemp, // EK9 Boolean result
        invertedPrimitiveTemp, // Inverted primitive condition
        rhsEvaluationInstructions,
        rhsTemp
    );

    // Default case: LHS is set → return LHS
    final var defaultBodyEvaluation = List.<IRInstr>of(); // LHS already evaluated

    // Create the elvis coalescing chain details
    final var controlFlowChainDetails = ControlFlowChainDetails.createElvisCoalescing(
        resultVariable,
        List.of(nullCheckCase, isSetCheckCase),
        defaultBodyEvaluation,
        lhsTemp,
        debugInfo,
        coalesceScopeId
    );

    instructions.addAll(apply(controlFlowChainDetails));

    instructions.add(ScopeInstr.exit(coalesceScopeId, debugInfo));
    stackContext.exitScope();

    return instructions;
  }

  /**
   * Generate CONTROL_FLOW_CHAIN for Comparison Coalescing operators (&lt;?, &gt;?, &lt;=?, &gt;=?).
   * Returns LHS if both operands valid and comparison true, else gracefully handles null/unset.
   * <p>
   * IR Structure: 6 cases + default<br>
   * Case 1: NULL_CHECK on LHS → if null, return RHS<br>
   * Case 2: IS_SET check on LHS → if not set, return RHS<br>
   * Case 3: NULL_CHECK on RHS → if null, return LHS<br>
   * Case 4: IS_SET check on RHS → if not set, return LHS<br>
   * Case 5: COMPARISON (LHS comp RHS) → if true, return LHS<br>
   * Default: return RHS<br>
   * </p>
   *
   * @param comparisonOperator The comparison operator method name (e.g., "_lt", "_gt", "_lteq", "_gteq")
   * @param chainType          The chain type for IR (e.g., "LESS_THAN_COALESCING_OPERATOR")
   */
  public List<IRInstr> generateComparisonCoalescing(final ExprProcessingDetails lhsDetails,
                                                    final ExprProcessingDetails rhsDetails,
                                                    final String comparisonOperator,
                                                    final String chainType) {
    final var resultVariable = lhsDetails.variableDetails().resultVariable();
    final var debugInfo = lhsDetails.variableDetails().debugInfo();

    // Create dedicated scope for comparison coalescing operator (matches Elvis pattern)
    final var coalesceScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    stackContext.enterScope(coalesceScopeId, debugInfo, IRFrameType.BLOCK);

    final var instructions = new ArrayList<IRInstr>();
    instructions.add(ScopeInstr.enter(coalesceScopeId, debugInfo));

    // Generate LHS evaluation - result stored in temp
    final var lhsTemp = stackContext.generateTempName();
    final var lhsTempDetails = new VariableDetails(lhsTemp, debugInfo);
    final var lhsProcessingDetails = new ExprProcessingDetails(lhsDetails.ctx().left, lhsTempDetails);
    final var lhsEvaluationInstructions = new ArrayList<>(rawExprProcessor.apply(lhsProcessingDetails));

    // Add IS_NULL check on LHS
    final var lhsNullCheckCondition = stackContext.generateTempName();
    lhsEvaluationInstructions.add(MemoryInstr.isNull(lhsNullCheckCondition, lhsTemp, debugInfo));

    // Generate RHS evaluation instructions (shared by multiple cases)
    final var rhsTemp = stackContext.generateTempName();
    final var rhsTempDetails = new VariableDetails(rhsTemp, debugInfo);
    final var rhsProcessingDetails = new ExprProcessingDetails(rhsDetails.ctx().right, rhsTempDetails);
    // Wrap RHS evaluation with memory management for proper ARC (RETAIN + SCOPE_REGISTER)
    final var rhsEvaluationInstructions = variableMemoryManagement.apply(
        () -> rawExprProcessor.apply(rhsProcessingDetails),
        rhsTempDetails
    );

    // Case 1: NULL_CHECK on LHS → if null, return RHS (unique scope ID)
    final var lhsNullCheckScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    final var lhsNullCheckCase = ConditionCaseDetails.createNullCheck(
        lhsNullCheckScopeId,
        lhsEvaluationInstructions,
        null, // No EK9 Boolean condition result for null check
        lhsNullCheckCondition, // primitive boolean condition
        rhsEvaluationInstructions,
        rhsTemp
    );

    // Case 2: IS_SET check on LHS → if NOT set, return RHS

    final var lhsIsSetResultTemp = stackContext.generateTempName();
    final var lhsIsSetResultDetails = new VariableDetails(lhsIsSetResultTemp, debugInfo);

    // Get LHS type for _isSet() call
    final var lhsType = typeNameOrException.apply(getRecordedSymbolOrException(lhsDetails.ctx().left));

    // Call _isSet() on LHS using helper (includes memory management)
    final var lhsIsSetCheckInstructions =
        new ArrayList<>(isSetEvaluationCreator.apply(lhsTemp, lhsType, lhsIsSetResultDetails));

    // Extract inverted primitive: if NOT set (use ._false() instead of ._negate()._true())
    final var lhsInvertedPrimitiveTemp = stackContext.generateTempName();
    final var callDetailsForIsFalse = new CallDetailsForIsFalse();
    lhsIsSetCheckInstructions.add(CallInstr.operator(
        new VariableDetails(lhsInvertedPrimitiveTemp, debugInfo),
        callDetailsForIsFalse.apply(lhsIsSetResultTemp)
    ));

    // Case 2: unique scope ID
    final var lhsIsSetCheckScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    final var lhsIsSetCheckCase = ConditionCaseDetails.createExpression(
        lhsIsSetCheckScopeId,
        lhsIsSetCheckInstructions,
        lhsIsSetResultTemp, // EK9 Boolean result
        lhsInvertedPrimitiveTemp, // Inverted primitive condition
        rhsEvaluationInstructions,
        rhsTemp
    );

    // Now evaluate RHS for cases 3 and 4
    final var rhsEvalInstructions = new ArrayList<>(rhsEvaluationInstructions);

    // Add IS_NULL check on RHS
    final var rhsNullCheckCondition = stackContext.generateTempName();
    rhsEvalInstructions.add(MemoryInstr.isNull(rhsNullCheckCondition, rhsTemp, debugInfo));

    // Case 3: NULL_CHECK on RHS → if null, return LHS (unique scope ID)
    final var rhsNullCheckScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    final var rhsNullCheckCase = ConditionCaseDetails.createNullCheck(
        rhsNullCheckScopeId,
        rhsEvalInstructions,
        null, // No EK9 Boolean condition result for null check
        rhsNullCheckCondition, // primitive boolean condition
        List.of(), // LHS already evaluated, no body needed
        lhsTemp
    );

    // Case 4: IS_SET check on RHS → if NOT set, return LHS

    final var rhsIsSetResultTemp = stackContext.generateTempName();
    final var rhsIsSetResultDetails = new VariableDetails(rhsIsSetResultTemp, debugInfo);

    // Get RHS type for _isSet() call
    final var rhsType = typeNameOrException.apply(getRecordedSymbolOrException(rhsDetails.ctx().right));

    // Call _isSet() on RHS using helper (includes memory management)
    final var rhsIsSetCheckInstructions =
        new ArrayList<>(isSetEvaluationCreator.apply(rhsTemp, rhsType, rhsIsSetResultDetails));

    // Extract inverted primitive: if NOT set (use ._false() instead of ._negate()._true())
    final var rhsInvertedPrimitiveTemp = stackContext.generateTempName();
    rhsIsSetCheckInstructions.add(CallInstr.operator(
        new VariableDetails(rhsInvertedPrimitiveTemp, debugInfo),
        callDetailsForIsFalse.apply(rhsIsSetResultTemp)
    ));

    // Case 4: unique scope ID
    final var rhsIsSetCheckScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    final var rhsIsSetCheckCase = ConditionCaseDetails.createExpression(
        rhsIsSetCheckScopeId,
        rhsIsSetCheckInstructions,
        rhsIsSetResultTemp, // EK9 Boolean result
        rhsInvertedPrimitiveTemp, // Inverted primitive condition
        List.of(), // LHS already evaluated, no body needed
        lhsTemp
    );

    // Case 5: COMPARISON (LHS comp RHS) → if true, return LHS
    final var comparisonInstructions = new ArrayList<IRInstr>();
    final var comparisonResultTemp = stackContext.generateTempName();
    final var comparisonResultDetails = new VariableDetails(comparisonResultTemp, debugInfo);

    // Create comparison call (e.g., lhs._lt(rhs))
    final var comparisonCallDetails = new CallDetails(
        lhsTemp,
        lhsType,
        comparisonOperator,
        List.of(rhsType),           // parameterTypes - types of parameters
        "org.ek9.lang::Boolean",
        List.of(rhsTemp),           // arguments - actual variable names to pass
        new CallMetaDataDetails(true, 2),
        false
    );

    comparisonInstructions.add(CallInstr.operator(comparisonResultDetails, comparisonCallDetails));
    comparisonInstructions.add(MemoryInstr.retain(comparisonResultTemp, debugInfo));
    comparisonInstructions.add(ScopeInstr.register(comparisonResultTemp, coalesceScopeId, debugInfo));

    // Extract primitive boolean from comparison result
    final var comparisonPrimitiveTemp = stackContext.generateTempName();
    comparisonInstructions.add(CallInstr.operator(
        new VariableDetails(comparisonPrimitiveTemp, debugInfo),
        callDetailsForIsTrue.apply(comparisonResultTemp)
    ));

    // Case 5: COMPARISON - unique scope ID
    final var comparisonScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    final var comparisonCase = ConditionCaseDetails.createExpression(
        comparisonScopeId,
        comparisonInstructions,
        comparisonResultTemp, // EK9 Boolean result
        comparisonPrimitiveTemp, // Primitive condition
        List.of(), // LHS already evaluated, no body needed
        lhsTemp
    );

    // Default case: return RHS
    final var defaultBodyEvaluation = List.<IRInstr>of(); // RHS already evaluated

    // Create the comparison coalescing chain details
    final var controlFlowChainDetails = ControlFlowChainDetails.createComparisonCoalescing(
        resultVariable,
        List.of(lhsNullCheckCase, lhsIsSetCheckCase, rhsNullCheckCase, rhsIsSetCheckCase, comparisonCase),
        defaultBodyEvaluation,
        rhsTemp,
        debugInfo,
        coalesceScopeId,
        chainType
    );

    instructions.addAll(apply(controlFlowChainDetails));

    instructions.add(ScopeInstr.exit(coalesceScopeId, debugInfo));
    stackContext.exitScope();

    return instructions;
  }

  /**
   * Generate IR for ternary operator: condition &lt;- thenValue : elseValue.
   * <p>
   * Pattern: CONTROL_FLOW_CHAIN with TERNARY_OPERATOR chain type
   * - Condition evaluation in tight scope
   * - True branch evaluates thenValue
   * - False branch (default) evaluates elseValue
   * </p>
   *
   * @param details ExprProcessingDetails containing result variable and ternary expression context
   * @return List of IR instructions for ternary operator
   */
  public List<IRInstr> generateTernary(final ExprProcessingDetails details) {
    final var ctx = details.ctx();
    final var instructions = new ArrayList<IRInstr>();
    final var debugInfo = details.variableDetails().debugInfo();

    // Extract ternary parts from grammar
    final var controlExpr = ctx.control;  // condition expression
    final var ternaryParts = ctx.ternaryPart();
    final var thenPart = ternaryParts.get(0);  // first ternaryPart (true branch)
    final var elsePart = ternaryParts.get(1);  // second ternaryPart (false branch)

    // Create scope for ternary evaluation
    final var ternaryScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    stackContext.enterScope(ternaryScopeId, debugInfo, IRFrameType.BLOCK);

    instructions.add(ScopeInstr.enter(ternaryScopeId, debugInfo));

    // 1. Evaluate condition in tight scope
    final var conditionScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    stackContext.enterScope(conditionScopeId, debugInfo, IRFrameType.BLOCK);

    final var conditionEvaluation = new ArrayList<IRInstr>();
    conditionEvaluation.add(ScopeInstr.enter(conditionScopeId, debugInfo));

    // Evaluate control expression
    final var conditionTemp = stackContext.generateTempName();
    final var conditionDetails = new VariableDetails(conditionTemp, debugInfo);
    conditionEvaluation.addAll(
        variableMemoryManagement.apply(
            () -> rawExprProcessor.apply(new ExprProcessingDetails(controlExpr, conditionDetails)),
            conditionDetails
        )
    );

    // Extract primitive boolean for branching
    final var primitiveCondition = stackContext.generateTempName();
    conditionEvaluation.add(CallInstr.operator(
        new VariableDetails(primitiveCondition, debugInfo),
        callDetailsForIsTrue.apply(conditionTemp)
    ));

    conditionEvaluation.add(ScopeInstr.exit(conditionScopeId, debugInfo));
    stackContext.exitScope();

    // 2. Create true branch (thenPart)
    final var thenScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    stackContext.enterScope(thenScopeId, debugInfo, IRFrameType.BLOCK);

    final var thenBodyEvaluation = new ArrayList<IRInstr>();
    thenBodyEvaluation.add(ScopeInstr.enter(thenScopeId, debugInfo));

    final var resultVariable = details.variableDetails().resultVariable();
    final var thenResultTemp = stackContext.generateTempName();
    final var thenResultDetails = new VariableDetails(thenResultTemp, debugInfo);

    thenBodyEvaluation.addAll(
        variableMemoryManagement.apply(
            () -> rawExprProcessor.apply(new ExprProcessingDetails(thenPart.expression(), thenResultDetails)),
            thenResultDetails
        )
    );

    // Store then result to output variable
    thenBodyEvaluation.add(MemoryInstr.release(resultVariable, debugInfo));
    thenBodyEvaluation.add(MemoryInstr.store(resultVariable, thenResultTemp, debugInfo));
    thenBodyEvaluation.add(MemoryInstr.retain(resultVariable, debugInfo));

    thenBodyEvaluation.add(ScopeInstr.exit(thenScopeId, debugInfo));
    stackContext.exitScope();

    // 3. Create false branch (elsePart) as default
    final var elseScopeId = stackContext.generateScopeId(IRConstants.GENERAL_SCOPE);
    stackContext.enterScope(elseScopeId, debugInfo, IRFrameType.BLOCK);

    final var elseBodyEvaluation = new ArrayList<IRInstr>();
    elseBodyEvaluation.add(ScopeInstr.enter(elseScopeId, debugInfo));

    final var elseResultTemp = stackContext.generateTempName();
    final var elseResultDetails = new VariableDetails(elseResultTemp, debugInfo);

    elseBodyEvaluation.addAll(
        variableMemoryManagement.apply(
            () -> rawExprProcessor.apply(new ExprProcessingDetails(elsePart.expression(), elseResultDetails)),
            elseResultDetails
        )
    );

    // Store else result to output variable
    elseBodyEvaluation.add(MemoryInstr.release(resultVariable, debugInfo));
    elseBodyEvaluation.add(MemoryInstr.store(resultVariable, elseResultTemp, debugInfo));
    elseBodyEvaluation.add(MemoryInstr.retain(resultVariable, debugInfo));

    elseBodyEvaluation.add(ScopeInstr.exit(elseScopeId, debugInfo));
    stackContext.exitScope();

    // 4. Create ConditionCaseDetails for true branch
    final var conditionCase = ConditionCaseDetails.createExpression(
        thenScopeId,
        conditionEvaluation,
        conditionTemp,
        primitiveCondition,
        thenBodyEvaluation,
        resultVariable
    );

    // 5. Build CONTROL_FLOW_CHAIN
    final var controlFlowDetails = ControlFlowChainDetails.createTernaryOperator(
        resultVariable,
        List.of(conditionCase),
        elseBodyEvaluation,
        resultVariable,
        debugInfo,
        ternaryScopeId
    );

    instructions.addAll(apply(controlFlowDetails));

    instructions.add(ScopeInstr.exit(ternaryScopeId, debugInfo));
    stackContext.exitScope();

    return instructions;
  }

  /**
   * Generate evaluation instructions for Boolean(false).
   */
  private List<IRInstr> generateBooleanFalseEvaluation(final VariableDetails variableDetails) {
    return booleanFalseEvaluationCreator.apply(variableDetails);
  }

  /**
   * Generate evaluation instructions for variable._isSet() - loads variable first.
   * Note: LOAD does NOT get memory management - only the _isSet() result does.
   */
  private List<IRInstr> generateIsSetEvaluationForVariable(final String variableName,
                                                           final String operandVariable,
                                                           final VariableDetails operandDetails,
                                                           final String operandType,
                                                           final VariableDetails resultDetails) {

    // Load variable for _isSet() method call (no memory management on the LOAD)
    final var instructions = new ArrayList<IRInstr>();
    instructions.add(MemoryInstr.load(operandVariable, variableName, operandDetails.debugInfo()));

    // Call _isSet() with memory management on the result
    instructions.addAll(isSetEvaluationCreator.apply(operandVariable, operandType, resultDetails));

    return instructions;
  }

  /**
   * Generate evaluation instructions for operand._isSet() without operand memory management.
   * Used by question operator which is self-contained and manages its own inputs.
   */
  private List<IRInstr> generateIsSetEvaluationNoOperandManagement(final String operandVariable,
                                                                   final String operandType,
                                                                   final VariableDetails resultDetails) {
    return isSetEvaluationCreator.apply(operandVariable, operandType, resultDetails);
  }

  /**
   * Generate evaluation instructions for boolean._not().
   */
  private List<IRInstr> generateBooleanNotEvaluation(final String booleanVariable,
                                                     final VariableDetails resultDetails) {
    return booleanNotEvaluationCreator.apply(booleanVariable, resultDetails);
  }
}