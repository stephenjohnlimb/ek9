package org.ek9lang.compiler.backend.jvm;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import org.ek9lang.compiler.backend.ConstructTargetTuple;
import org.ek9lang.compiler.common.INodeVisitor;
import org.ek9lang.compiler.ir.instructions.CallInstr;
import org.ek9lang.compiler.ir.instructions.IRConstruct;
import org.ek9lang.compiler.ir.instructions.LiteralInstr;
import org.ek9lang.compiler.ir.instructions.MemoryInstr;
import org.ek9lang.compiler.ir.instructions.ProgramEntryPointInstr;
import org.ek9lang.compiler.ir.instructions.ScopeInstr;
import org.ek9lang.core.AssertValue;
import org.ek9lang.core.CompilerException;

/**
 * Enhanced visitor that uses specialized ASM generators to produce JVM bytecode for IR constructs.
 * Implements visitor pattern with typed visit methods for each IR instruction type.
 * Uses single responsibility principle with separate generators for each instruction type.
 */
public final class OutputVisitor implements INodeVisitor {

  private final ConstructTargetTuple constructTargetTuple;

  // Static shared program registry for collecting metadata across all OutputVisitor instances
  // Only populated once from the first IRConstruct that has a ProgramEntryPointInstr
  private static final ProgramRegistry globalProgramRegistry = new ProgramRegistry();

  // Specialized ASM generators following single responsibility principle
  private final AsmStructureCreator asmStructureCreator;
  private final CallInstrAsmGenerator callInstrGenerator;
  private final LiteralInstrAsmGenerator literalInstrGenerator;
  private final MemoryInstrAsmGenerator memoryInstrGenerator;
  private final ScopeInstrAsmGenerator scopeInstrGenerator;
  private final ProgramEntryPointInstrAsmGenerator programEntryPointGenerator;

  public OutputVisitor(final ConstructTargetTuple constructTargetTuple) {
    AssertValue.checkNotNull("File cannot be null", constructTargetTuple.targetFile());
    this.constructTargetTuple = constructTargetTuple;
    asmStructureCreator = new AsmStructureCreator(constructTargetTuple, this);

    // Initialize specialized generators with shared ClassWriter from AsmStructureCreator
    final var classWriter = asmStructureCreator.getClassWriter();
    this.callInstrGenerator = new CallInstrAsmGenerator(constructTargetTuple, this, classWriter);
    this.literalInstrGenerator = new LiteralInstrAsmGenerator(constructTargetTuple, this, classWriter);
    this.memoryInstrGenerator = new MemoryInstrAsmGenerator(constructTargetTuple, this, classWriter);
    this.scopeInstrGenerator = new ScopeInstrAsmGenerator(constructTargetTuple, this, classWriter);
    this.programEntryPointGenerator = new ProgramEntryPointInstrAsmGenerator(constructTargetTuple, this, classWriter);
  }

  @Override
  public void visit() {
    visit(constructTargetTuple.construct());

    //So that should be it, as long as each IR Node has been asked to accept this visitor
    //then with the double dispatch each of the relevant IRNodes in the code should have been visited.
    final var byteCodes = asmStructureCreator.getByteCode();

    // Only save if we have actual bytecode
    if (byteCodes.length > 0) {
      try (var stream = new FileOutputStream(constructTargetTuple.targetFile())) {
        stream.write(byteCodes);
        System.out.println("Saved bytecodes to file " + constructTargetTuple.targetFile());
      } catch (IOException e) {
        System.err.println("Failed to save bytecodes to file " + constructTargetTuple.targetFile());
        throw new CompilerException("Unable to save generated bytecode", e);
      }
    }

    // Note: ek9/Main.class generation is handled at the end of all construct processing
    // in CodeGenerationAggregates phase to ensure it's generated only once
  }

  @Override
  public void visit(final IRConstruct construct) {
    asmStructureCreator.processClass();
  }

  /**
   * Typed visit method for CallInstr - delegates to specialized generator.
   */
  public void visit(final CallInstr callInstr) {
    callInstrGenerator.generateCall(callInstr);
  }

  /**
   * Typed visit method for LiteralInstr - delegates to specialized generator.
   */
  public void visit(final LiteralInstr literalInstr) {
    literalInstrGenerator.generateLiteral(literalInstr);
  }

  /**
   * Typed visit method for MemoryInstr - delegates to specialized generator.
   */
  public void visit(final MemoryInstr memoryInstr) {
    memoryInstrGenerator.generateMemoryOperation(memoryInstr);
  }

  /**
   * Typed visit method for ScopeInstr - delegates to specialized generator.
   */
  public void visit(final ScopeInstr scopeInstr) {
    scopeInstrGenerator.generateScopeOperation(scopeInstr);
  }

  /**
   * Typed visit method for ProgramEntryPointInstr - delegates to specialized generator.
   * Uses SharedThreadContext pattern for thread-safe main class generation.
   */
  public void visit(final ProgramEntryPointInstr programEntryPointInstr) {
    programEntryPointGenerator.generateProgramEntryPoint(programEntryPointInstr);
  }

  /**
   * Get the main ASM structure creator for access to ClassWriter.
   */
  public AsmStructureCreator getAsmStructureCreator() {
    return asmStructureCreator;
  }


  /**
   * Get the global program registry (static, shared across all OutputVisitor instances).
   */
  public static ProgramRegistry getGlobalProgramRegistry() {
    return globalProgramRegistry;
  }

  /**
   * Generate ek9/Main.class once at the end of compilation if program metadata has been collected.
   * Creates Main.class in the specified output directory.
   */
  public static void generateMainClassOnce(final String outputDirectoryPath) {
    System.out.println("DEBUG: generateMainClassOnce called with path: " + outputDirectoryPath);
    System.out.println("DEBUG: globalProgramRegistry.hasPrograms(): " + globalProgramRegistry.hasPrograms());

    if (!globalProgramRegistry.hasPrograms()) {
      return; // No programs to generate Main class for
    }

    try {
      // Create ek9 subdirectory if it doesn't exist
      final var outputDir = new File(outputDirectoryPath);
      final var ek9Dir = new File(outputDir, "ek9");
      if (!ek9Dir.exists() && !ek9Dir.mkdirs()) {
        System.err.println("Failed to create ek9 directory: " + ek9Dir.getAbsolutePath());
        return;
      }

      // Generate Main.class
      final var mainClassFile = new File(ek9Dir, "Main.class");
      final var mainClassGenerator = new MainClassGenerator(globalProgramRegistry.getPrograms());
      final var mainClassBytecode = mainClassGenerator.generateMainClass();

      // Write Main.class to file
      try (var stream = new FileOutputStream(mainClassFile)) {
        stream.write(mainClassBytecode);
        System.out.println("Generated ek9/Main.class with " + globalProgramRegistry.getProgramCount() + " program(s): "
            + mainClassFile.getAbsolutePath());
      }

    } catch (IOException e) {
      System.err.println("Failed to generate ek9/Main.class: " + e.getMessage());
      throw new CompilerException("Unable to generate ek9/Main.class", e);
    }
  }
}
