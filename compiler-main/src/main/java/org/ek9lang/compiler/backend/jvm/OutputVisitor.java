package org.ek9lang.compiler.backend.jvm;

import java.io.FileOutputStream;
import java.io.IOException;
import org.ek9lang.compiler.backend.ConstructTargetTuple;
import org.ek9lang.compiler.common.INodeVisitor;
import org.ek9lang.compiler.ir.instructions.CallInstr;
import org.ek9lang.compiler.ir.instructions.IRConstruct;
import org.ek9lang.compiler.ir.instructions.LiteralInstr;
import org.ek9lang.compiler.ir.instructions.MemoryInstr;
import org.ek9lang.compiler.ir.instructions.ScopeInstr;
import org.ek9lang.core.AssertValue;
import org.ek9lang.core.CompilerException;

/**
 * Enhanced visitor that uses specialized ASM generators to produce JVM bytecode for IR constructs.
 * Implements visitor pattern with typed visit methods for each IR instruction type.
 * Uses single responsibility principle with separate generators for each instruction type.
 */
public final class OutputVisitor implements INodeVisitor {

  private final ConstructTargetTuple constructTargetTuple;

  // Specialized ASM generators following single responsibility principle
  private final AsmStructureCreator asmStructureCreator;
  private final CallInstrAsmGenerator callInstrGenerator;
  private final LiteralInstrAsmGenerator literalInstrGenerator;
  private final MemoryInstrAsmGenerator memoryInstrGenerator;

  public OutputVisitor(final ConstructTargetTuple constructTargetTuple) {
    AssertValue.checkNotNull("File cannot be null", constructTargetTuple.targetFile());
    this.constructTargetTuple = constructTargetTuple;
    asmStructureCreator = new AsmStructureCreator(constructTargetTuple, this);

    // Initialize specialized generators with shared ClassWriter from AsmStructureCreator
    final var classWriter = asmStructureCreator.getClassWriter();
    this.callInstrGenerator = new CallInstrAsmGenerator(constructTargetTuple, this, classWriter);
    this.literalInstrGenerator = new LiteralInstrAsmGenerator(constructTargetTuple, this, classWriter);
    this.memoryInstrGenerator = new MemoryInstrAsmGenerator(constructTargetTuple, this, classWriter);
  }

  @Override
  public void visit() {
    visit(constructTargetTuple.construct());

    //So that should be it, as long as each IR Node has been asked to accept this visitor
    //then with the double dispatch each of the relevant IRNodes in the code should have been visited.
    final var byteCodes = asmStructureCreator.getByteCode();

    // Only save if we have actual bytecode
    if (byteCodes.length > 0) {
      try (var stream = new FileOutputStream(constructTargetTuple.targetFile())) {
        stream.write(byteCodes);
      } catch (IOException e) {
        System.err.println("Failed to save bytecodes to file " + constructTargetTuple.targetFile());
        throw new CompilerException("Unable to save generated bytecode", e);
      }
    }

    // Note: ek9/Main.class generation is handled at the end of all construct processing
    // in CodeGenerationAggregates phase to ensure it's generated only once
  }

  @Override
  public void visit(final IRConstruct construct) {
    asmStructureCreator.processClass();
  }

  /**
   * Typed visit method for CallInstr - delegates to specialized generator.
   */
  public void visit(final CallInstr callInstr) {
    callInstrGenerator.generateCall(callInstr);
  }

  /**
   * Typed visit method for LiteralInstr - delegates to specialized generator.
   */
  public void visit(final LiteralInstr literalInstr) {
    literalInstrGenerator.generateLiteral(literalInstr);
  }

  /**
   * Typed visit method for MemoryInstr - delegates to specialized generator.
   */
  public void visit(final MemoryInstr memoryInstr) {
    memoryInstrGenerator.generateMemoryOperation(memoryInstr);
  }

  /**
   * Typed visit method for ScopeInstr - delegates to specialized generator.
   */
  public void visit(final ScopeInstr scopeInstr) {
    //No-OP
  }
}
