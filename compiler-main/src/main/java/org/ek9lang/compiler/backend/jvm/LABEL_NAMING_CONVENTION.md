# JVM Bytecode Generator - Label Naming Convention

## Mandatory Pattern

ALL control flow generators MUST create labels using **scope IDs** from IR instructions.

**Never use result variables, loop variable names, or any other non-scope identifiers for label creation.**

## Pattern: createControlFlowLabel(prefix, scopeId)

### Correct Usage

```java
// Loop generators - use scopeId from instruction
final var label = createControlFlowLabel("while_start", instr.getScopeId());
final var label = createControlFlowLabel("for_asc", scopeMetadata.loopScopeId());

// Conditional generators - use scopeId from instruction
final var label = createControlFlowLabel("if_end", instr.getScopeId());
final var label = createControlFlowLabel("if_next", conditionCase.caseScopeId());

// Logical operation generators - use scopeId from instruction
final var label = createControlFlowLabel("and_short", instr.getScopeId());
final var label = createControlFlowLabel("qop_end", instr.getScopeId());
```

### Incorrect Usage (DO NOT DO THIS)

```java
// WRONG - uses result variable (fragile, relies on IR implementation detail)
final var label = createControlFlowLabel("qop_end", instr.getResult());

// WRONG - uses loop variable name (collides in nested loops with same variable)
final var label = createControlFlowLabel("for_asc", loopVariableName);

// WRONG - uses hardcoded counter (not thread-safe, not unique across methods)
static int counter = 0;
final var label = createControlFlowLabel("label", String.valueOf(counter++));

// WRONG - compounds result variable with scope ID (unnecessary complexity)
final var label = createControlFlowLabel("prefix_" + instr.getResult(), scopeId);
```

## Why Scope IDs?

### 1. **Guaranteed Uniqueness**
- IR generator ensures scope IDs are globally unique per method
- Generated by monotonic counter in `IRGenerationContext`
- No collisions possible, even with nested constructs

### 2. **Nested Construct Safety**
- Each nested scope automatically gets a unique ID
- Same variable names in nested loops: no collision
- Same operator types in nested contexts: no collision

### 3. **Semantic Clarity**
- Scope IDs represent lexical structure (semantically correct)
- Result variables represent computation outputs (operational detail)
- Labels should track scopes, not computation results

### 4. **Implementation Independence**
- Doesn't rely on temp variable naming scheme
- Immune to IR generator refactoring (e.g., temp variable reuse)
- Survives optimization passes that might change variable allocation

### 5. **Consistency**
- Established pattern across all existing loop/conditional generators
- Reduces cognitive load when reading/maintaining code
- Follows principle of least surprise

## Nested Construct Examples

### Example 1: Nested Loops (Same Variable Name)

**EK9 Code**:
```ek9
for i in 1 ... 10
  for i in 1 ... 5  // Same variable name "i"
    sum: sum + i
```

**IR Scope IDs** (automatically unique):
```
Outer loop: loopScopeId = "_scope_3"
Inner loop: loopScopeId = "_scope_6"
```

**Generated Labels** (no collision):
```
Outer: for_asc__scope_3, for_desc__scope_3, for_end__scope_3
Inner: for_asc__scope_6, for_desc__scope_6, for_end__scope_6  ‚úÖ
```

**If we used loop variable** (WRONG - would collide):
```
Outer: for_asc_i, for_desc_i, for_end_i
Inner: for_asc_i, for_desc_i, for_end_i  ‚ùå COLLISION!
```

---

### Example 2: Nested Conditionals

**EK9 Code**:
```ek9
if condition1
  if condition2
    action()
```

**IR Scope IDs** (automatically unique):
```
Outer: scopeId = "_scope_2", caseScopeId = "_scope_3"
Inner: scopeId = "_scope_4", caseScopeId = "_scope_5"
```

**Generated Labels** (no collision):
```
Outer: if_end__scope_2, if_next__scope_3
Inner: if_end__scope_4, if_next__scope_5  ‚úÖ
```

---

### Example 3: Nested Logical Operations

**EK9 Code**:
```ek9
result := ((a and b) or (c and d))
```

**IR Scope IDs** (automatically unique):
```
Inner AND 1: scopeId = "_scope_8"
Inner AND 2: scopeId = "_scope_9"
Outer OR:    scopeId = "_scope_10"
```

**Generated Labels** (no collision):
```
AND 1: and_short__scope_8, and_end__scope_8
AND 2: and_short__scope_9, and_end__scope_9
OR:    or_short__scope_10, or_end__scope_10  ‚úÖ
```

## Available Scope ID Accessors by IR Instruction Type

| IR Instruction Type | Scope ID Accessor | Usage |
|---|---|---|
| `ControlFlowChainInstr` | `instr.getScopeId()` | Main control flow structure scope |
| `ConditionCaseDetails` | `conditionCase.caseScopeId()` | Individual condition case scope |
| `ForRangePolymorphicInstr` | `instr.getScopeMetadata().loopScopeId()` | Loop control structure scope |
| `ForRangePolymorphicInstr` | `instr.getScopeMetadata().bodyScopeId()` | Loop body scope (per-iteration) |
| `LogicalOperationInstr` | `instr.getScopeId()` | Logical operation scope |

## Verification Checklist

When implementing a new control flow generator:

- [ ] **Use scope ID accessor** - Call the appropriate `getScopeId()` method
- [ ] **Never use result variable** - `instr.getResult()` is for computation, not labels
- [ ] **Never use variable names** - Variable names can collide in nested scopes
- [ ] **Document which scope ID** - Comment which scope field is used (loopScopeId, caseScopeId, etc.)
- [ ] **Test with nested constructs** - Create test with same variable names in nested scopes
- [ ] **Verify labels in javap** - Manually inspect bytecode to confirm unique labels
- [ ] **Check for pattern consistency** - Ensure label naming matches other generators

## Current Status (as of 2025-10-21)

### ‚úÖ Correct Generators (using scopeId)
- `WhileLoopAsmGenerator` - uses `instr.getScopeId()`
- `DoWhileLoopAsmGenerator` - uses `instr.getScopeId()`
- `IfElseAsmGenerator` - uses `instr.getScopeId()` and `conditionCase.caseScopeId()`
- `QuestionOperatorAsmGenerator` - **FIXED** to use `instr.getScopeId()`
- `LogicalOperationAsmGenerator` - **FIXED** to use `instr.getScopeId()`

### üî® To Implement
- `ForRangePolymorphicAsmGenerator` - **MUST** use `scopeMetadata.loopScopeId()`

### ‚úÖ Special Cases (not control flow)
- `BranchInstrAsmGenerator` - uses IR-provided label names (correct delegation)
- `LabelInstrAsmGenerator` - uses IR-provided label names (correct delegation)

## Implementation Pattern Template

```java
/**
 * Specialized generator for [CONSTRUCT NAME].
 */
final class [Construct]AsmGenerator extends AbstractControlFlowAsmGenerator {

  public void generate(final [InstrType] instr) {
    // STEP 1: Extract scope ID from instruction
    // Use the appropriate accessor for this instruction type:
    final var scopeId = instr.getScopeId();  // or scopeMetadata.loopScopeId(), etc.

    // STEP 2: Create labels using scopeId
    final var startLabel = createControlFlowLabel("prefix_start", scopeId);
    final var endLabel = createControlFlowLabel("prefix_end", scopeId);

    // STEP 3: For nested cases, use case-specific scope IDs
    for (var conditionCase : instr.getConditionChain()) {
      final var caseLabel = createControlFlowLabel(
          "prefix_case",
          conditionCase.caseScopeId());  // Each case has unique scope ID
      // ...
    }

    // STEP 4: Generate bytecode using created labels
    placeLabel(startLabel);
    // ... bytecode generation ...
    placeLabel(endLabel);
  }
}
```

## Testing Pattern

### Unit Test Structure
```java
class NestedConstructTest extends AbstractBytecodeGenerationTest {
  public NestedConstructTest() {
    super("/examples/bytecodeGeneration/nestedConstruct",
        List.of(new SymbolCountCheck("bytecode.test", 1)),
        false, false, false);
  }
}
```

### EK9 Test Code (nested constructs)
```ek9
defines module bytecode.test

  defines program

    NestedConstruct()
      for i in 1 ... 3
        for i in 1 ... 2  // Same variable name - tests label uniqueness
          sum: sum + 1
```

### Validation Command
```bash
# Run test and generate bytecode
mvn test -Dtest=NestedConstructTest -pl compiler-main

# Extract and inspect bytecode
javap -c -v target/test-classes/.ek9/bytecode.test/generated/jvm/bytecode.test.NestedConstruct

# Verify all labels are unique (grep for duplicate labels)
javap -c target/... | grep ":" | sort | uniq -d
# Should produce NO output (no duplicates)
```

## Common Pitfalls

### ‚ùå Pitfall 1: Using Result Variable "Because It's Unique"
**Wrong thinking**: "Result variables are unique, so they'll work for labels"
**Problem**: Relies on implementation detail, not semantic correctness
**Fix**: Use scope ID - it's semantically correct AND unique

### ‚ùå Pitfall 2: Compounding Result + Scope
**Wrong pattern**: `createControlFlowLabel("prefix_" + result, scopeId)`
**Problem**: Unnecessary complexity, scope ID alone is sufficient
**Fix**: Use scope ID only: `createControlFlowLabel("prefix", scopeId)`

### ‚ùå Pitfall 3: Not Testing Nested Constructs
**Wrong assumption**: "It works for simple cases, nested will be fine"
**Problem**: Label collisions only appear in nested scenarios
**Fix**: Always create nested test cases with same variable names

### ‚ùå Pitfall 4: Ignoring Existing Patterns
**Wrong approach**: "I'll create my own label naming scheme"
**Problem**: Inconsistency makes codebase harder to understand
**Fix**: Follow established pattern from WhileLoop/IfElse generators

## Summary

**Golden Rule**: **Always use scope IDs from IR instructions for label creation. Never use result variables, variable names, or custom counters.**

This ensures:
- ‚úÖ Guaranteed uniqueness across all nesting levels
- ‚úÖ Semantic correctness (labels track scopes, not computations)
- ‚úÖ Implementation independence (immune to IR refactoring)
- ‚úÖ Pattern consistency across all generators
- ‚úÖ Maintainability and code clarity
