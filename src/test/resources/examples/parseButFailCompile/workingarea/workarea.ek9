#!ek9
<?-
  Workspace.

  Organise and add more tests, then consider functions.
  //TODO move to POST_RESOLUTION_CHECKS phase.
  //Split out the other FULL_RESOLUTION code tests to a separate test file.

-?>
defines module just.workspace

  defines class

    <?-
      A totally un-constrained generic type where T could be anything (as long as it has the ? operator)
    -?>
    UnConstrainedGenericClass of type T
      default UnConstrainedGenericClass()

      check() as pure
        -> arg0 as T
        <- rtn as Boolean: arg0?

    <?-
      Used as a base without the ? operator.
    -?>
    C0 as open
      property1 <- Integer()
      C0()
        -> arg0 as Integer
        this.property1 :=: arg0

      getProperty1() as pure
        <- rtn as Integer: Integer(property1)

  defines function

    UnConstrainedGenericClassDemo3()
      //TODO expect this to fail because C0 does not have a ? operator
      //Maybe need to have a check phase, because only 'check for operator' notes it has been referenced.
      //Can also check constrained type and parameterization argument are compatible.

      demo as UnConstrainedGenericClass of C0: UnConstrainedGenericClass()

      result <- demo.check(C0(22))
      assert result

    Broken()

      @Error: FULL_RESOLUTION: NOT_RESOLVED
      assert missing

    <!-

    <?-
      Extends the base, adds ? operator
    -?>
    C0A extends C0
      C0A()
        -> arg0 as Integer
        super(arg0)

      operator ? as pure
        <- rtn as Boolean: getProperty1()?

    <?-
      A separate example including the ? operator.
    -?>
    C1 as open
      property1 <- Integer()
      C1()
        -> arg0 as Integer
        this.property1 :=: arg0

      getProperty1() as pure
        <- rtn as Integer: Integer(property1)

      default operator ?

    <?-
      Extend C1 and add in an additional method to check access.
    -?>
    C1A extends C1
      C1A()
        -> arg0 as Integer
        super(arg0)

      getDoubleValue()
        <- rtn as Integer: getProperty1() * 2

    <?-
      Just a demonstration of the fact that while operators can be used in generics, methods cannot unless T is constrained.
      But note that the checking that the actual type when this generic type is parameterised does check for the operators.
    -?>
    BrokenUnConstrainedGenericClass of type T
      default BrokenUnConstrainedGenericClass()

      check()
        -> arg0 as T
        @Error: FULL_RESOLUTION: METHOD_NOT_RESOLVED
        <- rtn as Boolean: arg0.getProperty1()?

    <?-
      Now the type T has been constrained the rules are much stricter and only methods and operators from the
      constraining type can be used (even when defining the generic type).
    -?>
    BrokenConstrainedGenericClass of type T constrain by C0
      default ConstrainedGenericClass()

      //Now because we have constrained to C0, we can be assured of the methods and operators available
      check()
        -> arg0 as T
        @Error: FULL_RESOLUTION: OPERATOR_NOT_DEFINED
        <- rtn as Boolean: arg0?

    <?-
      Now create a generic type that limits use to classes that are a C0A or extend a C0A.
    -?>
    ConstrainedGenericClassCOA of type T constrain by C0A
      default ConstrainedGenericClassC0A()

      //But this will now be OK because it has the operator ?
      check()
        -> arg0 as T
        <- rtn as Boolean: arg0?

    <?-
      But now you can see it is possible to call the getProperty1 method because it is constraint to be a C0.
      Or could be a class that extends a C0.
    -?>
    ConstrainedGenericClass2 of type T constrain by C0
      default ConstrainedGenericClass2()

      check()
        -> arg0 as T
        <- rtn as Boolean: arg0.getProperty1()?

    <?-
      Yes another constrained generic type to a C1 or a type that extends a C1.
    -?>
    ConstrainedGenericClassC1 of type T constrain by C1
      default ConstrainedGenericClassC1()

      //But this will now be OK because it too has the operator ?
      check()
        -> arg0 as T
        <- rtn as Boolean: arg0?

  <?-
    Now some example functions that use the classes defined above.
  -?>
  defines function

    UnConstrainedGenericClassWithIntegerDemo1()
      demo as UnConstrainedGenericClass of Integer: UnConstrainedGenericClass()
      result <- demo.check(22)
      assert result

    UnConstrainedGenericClassWithIntegerDemo2()
      //Note that you can pass in a value here, the value does not have to be used in the generic type
      //But can be used as a 'prototype' type so that the generic type can be inferred.
      demo <- UnConstrainedGenericClass(23)
      result <- demo.check(22)
      assert result

    UnConstrainedGenericClassDemo2()
      demo as UnConstrainedGenericClass of C0: UnConstrainedGenericClass()

      //Cannot pass an Integer in need to be a C0
      @Error: FULL_RESOLUTION: METHOD_NOT_RESOLVED
      result <- demo.check(22)

      @Error: FULL_RESOLUTION: TYPE_NOT_RESOLVED
      assert result

    ConstrainedGenericClassCOADemo4()
      //TODO expect this to fail because C0A is the constraining type - put incorrect error here for now
      @Error: FULL_RESOLUTION: NOT_RESOLVED
      demo as ConstrainedGenericClassCOA of C0: ConstrainedGenericClassCOA()

      result <- demo.check(C0(22))
      assert result

    ConstrainedGenericClassCOADemo5()
      //This will be fine
      demo as ConstrainedGenericClassCOA of C0A: ConstrainedGenericClassCOA()

      //But this will not because the type is incorrect
      @Error: FULL_RESOLUTION: METHOD_NOT_RESOLVED
      result <- demo.check(C0(22))

      @Error: FULL_RESOLUTION: TYPE_NOT_RESOLVED
      assert result

    ConstrainedGenericClassCOADemo6()
      //This will be fine
      demo as ConstrainedGenericClassCOA of C0A: ConstrainedGenericClassCOA()

      result <- demo.check(C0A(22))
      assert result

    ConstrainedGenericClassC1Demo7()
      demo as ConstrainedGenericClassC1 of C1: ConstrainedGenericClassC1()

      //Check can be used with a C1 and a C1A
      result1 <- demo.check(C1(22))
      assert result1

      result2 <- demo.check(C1A(22))
      assert result2

    <?-
      Now try with a tighter constraint and check C0 cannot be used.
    -?>
    ConstrainedGenericClassC1Demo8()
      demo as ConstrainedGenericClassC1 of C1A: ConstrainedGenericClassC1()

      @Error: FULL_RESOLUTION: METHOD_NOT_RESOLVED
      result1 <- demo.check(C1(22))

      @Error: FULL_RESOLUTION: TYPE_NOT_RESOLVED
      assert result1

      //But this will still be OK
      result2 <- demo.check(C1A(22))
      assert result2


    Broken()

      @Error: FULL_RESOLUTION: NOT_RESOLVED
      assert missing
    -!>

//EOF

