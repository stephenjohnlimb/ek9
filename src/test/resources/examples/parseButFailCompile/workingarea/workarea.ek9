#!ek9
<?-
  Adding in some tests that cause duplicate methods in generic types.
  This is very complex when taking dependent types into account as well.

  This means we can only detect them when they are parameterised.

  TODO add in checks on typedef (maybe) to see if identifierReference is actually a generic type - that is missing parameterizing.
-?>
defines module bad.duplicate.genericclassmethods

  defines class

    G1 of type T

      methodA()
        -> arg0 as String
        <- rtn as Boolean: true

      methodA()
        -> arg0 as Float
        <- rtn as Boolean: true

      //TODO error here just returning a G1, rather than and G1 of T
      //So some 'as' something must detect if we're missing 'of T'.
      //TODO this new test needs to be in an earlier phase.
      operator + as pure
        -> arg0 as Integer
        <- rtn as G1 of T: this

      operator + as pure
        -> arg0 as Float
        <- rtn as G1 of T: this

      default operator ?

    //Create a generic type that accepts two parameterizing arguments.
    //Now add in two overloaded methods that by themselves are fine.
    //But as and when we parameterize this polymorphic type may or may not work.
    //If used with G2 of (Integer, String), we'll be fine, but
    //if used with G2 as (Integer, Integer), then we will have duplicate methods.
    @Error: FULL_RESOLUTION: METHOD_DUPLICATED
    G2 of type (K, V)
      k as K?
      v as V?

      G2()
        ->
          k as K
          v as V

        //Just try using a hidden internal implementation of a dependent generic type
        //this is something that does not appear in any method interface
        //Within generics/templates we have to be explicit about types for now.
        somethingInternal as InternalDependentForG2 of (K, V): InternalDependentForG2(k, v)

        //Does not really do anything, just want to check the types align.
        s as K: somethingInternal.getS()
        t as V: somethingInternal.getT()

        this.k: s
        this.v: t

      @Error: FULL_RESOLUTION: METHOD_DUPLICATED
      set()
        -> k as K
        this.k: k

      @Error: FULL_RESOLUTION: METHOD_DUPLICATED
      set()
        -> v as V
        this.v: v

      get()
        <- rtn as DependentForG2 of (K, V): DependentForG2(k, v)

      default operator ?

    //Added this and two set methods to check we can detect duplicates on a dependent type.
    @Error: FULL_RESOLUTION: METHOD_DUPLICATED
    DependentForG2 of type (K, V)
      k as K?
      v as V?

      DependentForG2()
        ->
          k as K
          v as V
        this.k: k
        this.v: v

      @Error: FULL_RESOLUTION: METHOD_DUPLICATED
      set()
        -> k as K
        this.k: k

      @Error: FULL_RESOLUTION: METHOD_DUPLICATED
      set()
        -> v as V
        this.v: v

      getK()
        <- rtn as K: k

      getV()
        <- rtn as V: v

    InternalDependentForG2 of type (S, T)
      s as S?
      t as T?

      InternalDependentForG2()
        ->
          s as S
          t as T
        this.s: s
        this.t: t

      getS()
        <- rtn as S: s
      getT()
        <- rtn as T: t

  defines function

    //Just temporary to cause a known failure.
    JustToFail()

      @Error: FULL_RESOLUTION: NOT_RESOLVED
      var <- NoSuch()

    CheckExplicitParameterizedG1()
      var as G1 of Integer: G1()
      assert var?

    CheckInferredParameterizedG1()
      var <- G1(42)
      assert var?

    CheckExplicitParameterizedG2()
      var as G2 of (Integer, String): G2()
      assert var?

    CheckInferredParameterizedG2()
      //This is fine and will not result in duplicate methods in G2.
      var <- G2(21, "Steve")
      assert var?

    CheckInferredParameterizedG2SameType()

      //The inferred use of G2 will cause method duplication in G2 'set' operations.
      //Those are highlighted as being in error, but are only an error, because two integers are used.
      //So this tends to mean that the use of the generic/template type could be written better or that it is not
      //really designed to work with two types that are the same.
      //Again here this is actually the source of the error: @Error: FULL_RESOLUTION: METHOD_DUPLICATED
      var <- G2(String, String)
      assert var?

    //TODO at this point need to check for method duplication
    //TODO set(K) and set(V), both map to set(Integer), set(Integer)
    CheckExplicitParameterizedG2SameType()
      //This really where I want the error: @Error: FULL_RESOLUTION: METHOD_DUPLICATED
      var as G2 of (Integer, Integer): G2()
      assert var?

//EOF