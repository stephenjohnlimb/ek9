#!ek9
<?-
  Starting work on the mammoth task of streams.
  These are the main parts, note the statement does not return anything (i.e. must end in an output to something)
  But the expression does 'return something', could be a collection, or in a reduction just an instance of type.
  Main two constructions: streamStatement, streamExpression:
  Both begin with: streamSource - which can be one of either: streamCat, streamFor:
  Stream statements then have: streamPart(s)/streamStatementTermination - pipelinePart
  But Stream expressions have streamPart(s) - pipelinePart and finally: streamExpressionTermination

  The main phased approach in the definition phase is to build the 'structure' of the pipeline.
  The next phase (in order) is to workout the types, this can only be completed during phase 3 due to type inference.
  The tricky bit is ensuring that the types that flow through the pipeline align with outputs to inputs.
  This is made more complex by some pipeline parts being able to accept 'anything' and output the same type.

  So the processing is sort of strict at the start and the end (in terms of types) and also strict when any functions are employed.
  But more flexible for things like 'skipping', 'head', 'tail' for example.
  Then for some operations like 'flatten', there has to be some way to 'iterate' over the type to get the 'flattened values'.
  Other operations like 'uniq' will require operators on the type - like 'hashCode' for example.
  But 'sort' accepts any 'T' and output a 'List of T', flatten accepts some type of 'Â§T' and if it has an iterator method outputs 'T'.

  filter and select next to do.

  So, this is pretty complex stuff.

-?>
defines module just.workspace

  defines class

    StringCollector
      joined <- String()

      operator |
        -> arg0 as Integer
        if arg0?
          if joined?
            joined += " " + $arg0
          else
            joined: String($arg0)

      operator ? as pure
        <- rtn as Boolean: joined?

  defines function

    GreaterThanCheck()
      -> value as Integer
      <- rtn as Boolean: value > 2

    VoidReturnFunction()
      -> value as Integer
      assert value?

    WrongReturnTypeFunction()
      -> value as Integer
      <- rtn as Integer: value*value

    WrongInputTypeFunction()
      -> value as Date
      <- rtn as Boolean: value?

    JustFail()
      @Error: FULL_RESOLUTION: NOT_RESOLVED
      assert notDefined?

    SimpleStreamCatFilter1()
      collector <- StringCollector()

      cat [1, 2, 3, 4] | filter with GreaterThanCheck > collector
      assert collector?

    BrokenStreamCatFilter1()
      collector <- StringCollector()

      @Error: FULL_RESOLUTION: NOT_RESOLVED
      cat [1, 2, 3, 4] | filter with NoSuch > collector
      assert collector?

    BrokenStreamCatFilter2()
      collector <- StringCollector()

      @Error: FULL_RESOLUTION: NOT_RESOLVED
      cat [1, 2, 3, 4] | filter with NoSuchCall() > collector
      assert collector?

    BrokenStreamCatFilter3()
      collector <- StringCollector()

      someInteger <- 1
      @Error: FULL_RESOLUTION: FUNCTION_OR_DELEGATE_REQUIRED
      cat [1, 2, 3, 4] | filter with someInteger > collector
      assert collector?

    BrokenStreamCatFilter4()
      collector <- StringCollector()

      @Error: FULL_RESOLUTION: MUST_RETURN_BOOLEAN
      cat [1, 2, 3, 4] | filter with VoidReturnFunction > collector
      assert collector?

    BrokenStreamCatFilter5()
      collector <- StringCollector()

      @Error: FULL_RESOLUTION: MUST_RETURN_BOOLEAN
      cat [1, 2, 3, 4] | filter with WrongReturnTypeFunction > collector
      assert collector?

    BrokenStreamCatFilter6()
      collector <- StringCollector()

      @Error: FULL_RESOLUTION: INCOMPATIBLE_TYPES
      cat [1, 2, 3, 4] | filter with WrongInputTypeFunction > collector
      assert collector?

  <!-

   SimpleStreamCatMap4()
      collector <- StringCollector()
      //Check if the Optional has an Iterator of type Integer so it can be streamed
      //Use a function that extends an abstract function.
      //TODO fix big error in generics processing.
      cat Optional(1) | map with IntegerToString > collector
      assert collector?

  //Sort out the normal statements and then do these expressions, or maybe add a separate test file
  defines function
    SimpleStreamExpression()
      //here are some durations to sum up (collect) 2 days, 1 week and 2 hours.
      collectedDurations <- cat [P2D, P1W, PT2H] | collect as DurationCollector
      assert collectedDurations.duration()?

    BrokenExpressionTerminator1()
      //This is currently not quite right, DurationCollector cannot accept integers
      @Error: FULL_RESOLUTION: TYPE_NOT_RESOLVED
      collectedDurations <- cat [1, 2, 3] | collect as DurationCollector
      assert collectedDurations?
  -!>

//EOF

