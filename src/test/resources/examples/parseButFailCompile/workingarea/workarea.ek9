#!ek9
<?-
  Starting work on the mammoth task of streams.
  These are the main parts, note the statement does not return anything (i.e. must end in an output to something)
  But the expression does 'return something', could be a collection, or in a reduction just an instance of type.
  Main two constructions: streamStatement, streamExpression:
  Both begin with: streamSource - which can be one of either: streamCat, streamFor:
  Stream statements then have: streamPart(s)/streamStatementTermination - pipelinePart
  But Stream expressions have streamPart(s) - pipelinePart and finally: streamExpressionTermination

  The main phased approach in the definition phase is to build the 'structure' of the pipeline.
  The next phase (in order) is to workout the types, this can only be completed during phase 3 due to type inference.
  The tricky bit is ensuring that the types that flow through the pipeline align with outputs to inputs.
  This is made more complex by some pipeline parts being able to accept 'anything' and output the same type.

  So the processing is strict at the start and the end (in terms of types) and also strict when any functions are employed.
  But more flexible for things like 'skipping', 'head', 'tail' for example.
  Then for some operations like 'flatten', there has to be some way to 'iterate' over the type to get the 'flattened values'.

  The 'sort' accepts any 'T' and if used without a function expects the 'T' to have a comparator method. If it is used with a function
  then that function must accept two arguments of 'T' and return an Integer (i.e. be a comparator.)

  But 'group' a little list 'split' accepts any 'T' and outputs a 'List of T', flatten accepts some type of 'Â§T' and if it has an iterator method outputs 'T'.

  Operations like 'uniq' will require operators on the type - like 'hashCode' for example, unless used with a Function - then that function has to be
  able to accept a type that is compatible with the pipeline type and return an Integer (the hashcode).

  So, this is pretty complex stuff.

-?>
defines module just.workspace

  <?-
    The utility functions used for testing in this example.
  -?>
  defines function

    JustFail()
      @Error: FULL_RESOLUTION: NOT_RESOLVED
      assert notDefined?

    AbstractStringJoiner() as abstract
      ->
        arg0 as String
        arg1 as String
      <-
        rtn as String?

    IntegerAdder()
      ->
        arg0 as Integer
        arg1 as Integer
      <-
        rtn as Integer: Integer()
      if arg0? and arg1?
        rtn :=: arg0 + arg1
      else if arg0?
        rtn :=: arg0
      else if arg1?
        rtn :=: arg1

    StringJoiner()
      ->
        arg0 as String
        arg1 as String
      <-
        rtn as String: String()
      if arg0? and arg1?
        rtn: "${arg0},${arg1}"
      else if arg0?
        rtn: "${arg0}"
      else if arg1?
        rtn: "${arg1}"

    InvalidStringJoiner1()
      ->
        arg0 as String
        arg1 as Duration
      <-
        rtn as String: String()

    InvalidStringJoiner2()
      -> arg0 as String
      <- rtn as String: String()

    InvalidStringJoiner3()
      ->
        arg0 as String
        arg1 as String
      assert arg0? and arg1?

    InvalidStringJoiner4()
      ->
        arg0 as String
        arg1 as String
      <-
        rtn as Duration: Duration()

    SimpleStreamCatJoin1()
      result <- String()
      cat ["A", "B", "C", "D"] | join with StringJoiner > result
      assert result?

    SimpleStreamCatJoin2()
      result <- String()
      joiner <- () is AbstractStringJoiner as function (rtn: "${arg0}, ${arg1}")

      cat ["A", "B", "C", "D"] | join with joiner > result
      assert result?

    <?-
      Join always requires a function to do the joining.
    -?>
    InvalidStreamCatJoin1()
      result <- String()

      @Error: FULL_RESOLUTION: FUNCTION_OR_DELEGATE_REQUIRED
      cat ["A", "B", "C", "D"] | join > result
      assert result?

    <?-
      So a function has been supplied, and it could be a joiner, but of Integers (adding in this case)
    -?>
    InvalidStreamCatJoin2()
      result <- String()

      @Error: FULL_RESOLUTION: INCOMPATIBLE_TYPE_ARGUMENTS
      cat ["A", "B", "C", "D"] | join IntegerAdder > result
      assert result?

    <?-
      The types of the arguments are not compatible.
    -?>
    InvalidStreamCatJoin3()
      result <- String()

      @Error: FULL_RESOLUTION: INCOMPATIBLE_TYPE_ARGUMENTS
      cat ["A", "B", "C", "D"] | join InvalidStringJoiner1 > result
      assert result?

    <?-
      Does not have two arguments.
    -?>
    InvalidStreamCatJoin4()
      result <- String()

      @Error: FULL_RESOLUTION: FUNCTION_MUST_HAVE_TWO_PARAMETERS
      cat ["A", "B", "C", "D"] | join InvalidStringJoiner2 > result
      assert result?

    <?-
      Does not have a return value and type.
    -?>
    InvalidStreamCatJoin5()
      result <- String()

      @Error: FULL_RESOLUTION: RETURNING_MISSING
      cat ["A", "B", "C", "D"] | join InvalidStringJoiner3 > result
      assert result?

    <?-
      Does have a return value and type, but the type is incompatible with the current pipeline type.
    -?>
    InvalidStreamCatJoin6()
      result <- String()

      @Error: FULL_RESOLUTION: INCOMPATIBLE_TYPES
      cat ["A", "B", "C", "D"] | join InvalidStringJoiner4 > result
      assert result?

    <?-
      Try to use join with something that is not even a function.
    -?>
    InvalidStreamCatJoin7()
      result <- String()

      notAFunctionAsAll <- 9
      @Error: FULL_RESOLUTION: FUNCTION_OR_DELEGATE_REQUIRED
      cat ["A", "B", "C", "D"] | join notAFunctionAsAll > result
      assert result?

    <?-
      While the function signature is compatible, it abstract and so cannot be used.
    -?>
    InvalidStreamCatJoin8()
      result <- String()

      @Error: FULL_RESOLUTION: CANNOT_CALL_ABSTRACT_TYPE
      cat ["A", "B", "C", "D"] | join AbstractStringJoiner > result
      assert result?


  <!-

   SimpleStreamCatMap4()
      collector <- StringCollector()
      //Check if the Optional has an Iterator of type Integer so it can be streamed
      //Use a function that extends an abstract function.
      //TODO fix big error in generics processing.
      cat Optional(1) | map with IntegerToString > collector
      assert collector?

  //Sort out the normal statements and then do these expressions, or maybe add a separate test file
  defines function
    SimpleStreamExpression()
      //here are some durations to sum up (collect) 2 days, 1 week and 2 hours.
      collectedDurations <- cat [P2D, P1W, PT2H] | collect as DurationCollector
      assert collectedDurations.duration()?

    BrokenExpressionTerminator1()
      //This is currently not quite right, DurationCollector cannot accept integers
      @Error: FULL_RESOLUTION: TYPE_NOT_RESOLVED
      collectedDurations <- cat [1, 2, 3] | collect as DurationCollector
      assert collectedDurations?
  -!>

//EOF

