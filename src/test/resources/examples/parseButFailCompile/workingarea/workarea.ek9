#!ek9
<?-
  Starting work on the mammoth task of streams.
  These are the main parts, note the statement does not return anything (i.e. must end in an output to something)
  But the expression does 'return something', could be a collection, or in a reduction just an instance of type.
  Main two constructions: streamStatement, streamExpression:
  Both begin with: streamSource - which can be one of either: streamCat, streamFor:
  Stream statements then have: streamPart(s)/streamStatementTermination - pipelinePart
  But Stream expressions have streamPart(s) - pipelinePart and finally: streamExpressionTermination

  The main phased approach in the definition phase is to build the 'structure' of the pipeline.
  The next phase (in order) is to workout the types, this can only be completed during phase 3 dues to type inference.
  The tricky bit is ensuring that the types that flow through the pipeline align with outputs to inputs.
  This is made more complex by some pipeline parts being able to accept 'anything' and output the same type.

  So the processing is sort of strict at the start and the end (in terms of types) and also strict when any functions are employed.
  But more flexible for things like 'skipping', 'head', 'tail' for example.
  Then for some operations like 'flatten', there has to be some way to 'iterate' over the type to get the 'flattened values'.
  Other operations like 'uniq' will require operators on the type - like 'hashCode' for example.

  //TODO StreamFor.
  So, this is pretty complex stuff.

-?>
defines module just.workspace

  defines function

    JustFail()
      @Error: FULL_RESOLUTION: NOT_RESOLVED
      assert notDefined?

    SimpleStreamCat1()
      stdout <- Stdout()
      cat [1, 2, 3] > stdout

    <?-
      This will cat each letter in the strings.
      But only because the String has an iterator method.
    -?>
    SimpleStreamCat2()
      stdout <- Stdout()
      cat "Steve", " ", "Limb" > stdout

    SimpleStreamFor1()
      stdout <- Stdout()
      for i in 1 ... 10 > stdout

    SimpleStreamFor2()
      stdout <- Stdout()
      for i in 'a' ... 'z' > stdout

    <?-
      This will fail because float cannot be iterated over.
    -?>
    BrokenStreamCat1()
      stdout <- Stdout()
      @Error: FULL_RESOLUTION: MISSING_ITERATE_METHOD
      cat [1, 2, 3], 3.5 > stdout

    <?-
      This will fail because none of the type have an iterate method.
    -?>
    BrokenStreamCat2()
      stdout <- Stdout()
      @Error: FULL_RESOLUTION: MISSING_ITERATE_METHOD
      cat 1, 2, 3, 3.5, 4 > stdout

    <?-
      nonSuch does not resolve, so that will cause an error.
      The 'cat' would just use Integer in this case, but compilation would fail dues to 'nonSuch'
    -?>
    BrokenStreamCat3()
      stdout <- Stdout()
      @Error: FULL_RESOLUTION: NOT_RESOLVED
      cat [1, 2, 3], nonSuch > stdout

    BrokenStreamFor1()
      stdout <- Stdout()
      @Error: FULL_RESOLUTION: UNABLE_TO_DETERMINE_COMMON_TYPE
      for i in 'a' ... 10 > stdout

//EOF

