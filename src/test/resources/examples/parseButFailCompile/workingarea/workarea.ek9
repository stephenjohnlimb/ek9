#!ek9
<?-
  Still have generics issues, but also resolution issues to sort out.

-?>
defines module just.workspace

  <?-
    The utility functions used for testing in this example.
  -?>
  defines function

    JustFail()
      @Error: FULL_RESOLUTION: NOT_RESOLVED
      assert notDefined?

    prop4()
      <- rtn <- 21

  defines class

    C1
      //First some properties
      prop1 <- 1

      prop2 <- 250ms

      prop3 <- PT10S

      //Then some methods
      prop2()
        <- rtn as Date: 2024-04-11

      //Now check the resolution works correctly
      methodA()

        //This resolves OK because there is only a property to resolve
        value1 as Integer: prop1
        assert value1?

        //This is the error, prop2 should resolve to the property not the method.
        value2 as Millisecond: prop2
        assert value2?

        //Now this does resolve Ok, but because it is a call.
        value3 as Date: prop2()
        assert value3?

        //Check it is possible to resolve a function.
        value4 as Integer: prop4()
        assert value4?

        //Bad name because not a property - but lets check it can get resolved.
        prop5 <- () extends Function of (String, String) as pure function (r :=? t)

        prop5CallResultAsUnit <- prop5("Steve")
        assert prop5CallResultAsUnit?

        //Check that this can be resolved and used in the same way as the delegate
        aliasToProp5 <- prop5
        aliasToProp5CallResultAsUnit <- aliasToProp5("Stephen")

        //Check that the result is the right type by using the wrong type
        @Error: FULL_RESOLUTION: INCOMPATIBLE_TYPES
        prop5CallResultAsUnit := 1

        @Error: FULL_RESOLUTION: INCOMPATIBLE_TYPES
        aliasToProp5CallResultAsUnit := 2024-04-13

        //Now assign to correct types
        prop5CallResultAsUnit := "Steve Limb"
        aliasToProp5CallResultAsUnit := "Also Steve Limb"

        assert prop5CallResultAsUnit? and aliasToProp5CallResultAsUnit?

  <!-

    SimpleStreamCatMap4()
      collector <- StringCollector()
      //Check if the Optional has an Iterator of type Integer so it can be streamed
      //Use a function that extends an abstract function.
      //TODO fix big error in generics processing.
      cat Optional(1) | map with IntegerToString > collector
      assert collector?

  //Sort out the normal statements and then do these expressions, or maybe add a separate test file
  defines function
    SimpleStreamExpression()
      //here are some durations to sum up (collect) 2 days, 1 week and 2 hours.
      collectedDurations <- cat [P2D, P1W, PT2H] | collect as DurationCollector
      assert collectedDurations.duration()?

    BrokenExpressionTerminator1()
      //This is currently not quite right, DurationCollector cannot accept integers
      @Error: FULL_RESOLUTION: TYPE_NOT_RESOLVED
      collectedDurations <- cat [1, 2, 3] | collect as DurationCollector
      assert collectedDurations?
  -!>

//EOF

