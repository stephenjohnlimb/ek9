#!ek9
<?-
  Adding in some tests that cause duplicate methods in generic types.
  This is very complex when taking dependent types into account as well.

  This means we can only detect them when they are parameterised.

  TODO add in checks on typedef (maybe) to see if identifierReference is actually a generic type - that is missing parameterizing.
-?>
defines module bad.duplicate.genericclassmethods

  defines class

    G1 of type T

      methodA()
        -> arg0 as String
        <- rtn as Boolean: true

      methodA()
        -> arg0 as Float
        <- rtn as Boolean: true

      //TODO error here just returning a G1, rather than and G1 of T
      //So some 'as' something must detect if we're missing 'of T'.
      operator + as pure
        -> arg0 as Integer
        <- rtn as G1 of T: this

      operator + as pure
        -> arg0 as Float
        <- rtn as G1 of T: this

      default operator ?

    //Create a generic type that accepts two parameterizing arguments.
    //Now add in two overloaded methods that by themselves are fine.
    //But as and when we parameterize this polymorphic type may or may not work.
    //If used with G2 of (Integer, String), we'll be fine, but
    //if used with G2 as (Integer, Integer), then we will have duplicate methods.
    G2 of type (K, V)
      k as K?
      v as V?

      G2()
        ->
          k as K
          v as V

        this.k: k
        this.v: v

      //@Error: FULL_RESOLUTION: METHOD_DUPLICATED
      set()
        -> k as K
        this.k: k

      //@Error: FULL_RESOLUTION: METHOD_DUPLICATED
      set()
        -> v as V
        this.v: v

      get()
        <- rtn as DependentForG2 of (K, V): DependentForG2(k, v)

      default operator ?

    //Added this and two set methods to check we can detect duplicates on a dependent type.
    DependentForG2 of type (K, V)
      k as K?
      v as V?

      DependentForG2()
        ->
          k as K
          v as V
        this.k: k
        this.v: v

      set()
        -> k as K
        this.k: k

      set()
        -> v as V
        this.v: v

      getK()
        <- rtn as K: k

      getV()
        <- rtn as V: v

  defines function

    JustToFail()

      @Error: FULL_RESOLUTION: NOT_RESOLVED
      var <- NoSuch()

    CheckExplicitParameterizedG1()
      var as G1 of Integer: G1()
      assert var?

    CheckInferredParameterizedG1()
      var <- G1(42)
      assert var?

    CheckExplicitParameterizedG2()
      var as G2 of (Integer, String): G2()
      assert var?

    CheckInferredParameterizedG2()
      //This is fine and will not result in duplicate methods in G2.
      var <- G2(21, "Steve")
      assert var?

    CheckInferredParameterizedG2SameType()

      //The inferred use of G2 will cause method duplication in G2 'set' operations.
      //Those are highlighted as being in error, but are only an error, because two integers are used.
      //So this tends to mean that the use of the generic/template type could be written better or that it is not
      //really designed to work with two types that are the same.
      //@Error: FULL_RESOLUTION: METHOD_DUPLICATED
      var <- G2(21, 42)
      assert var?

    //TODO at this point need to check for method duplication
    //TODO set(K) and set(V), both map to set(Integer), set(Integer)
    CheckExplicitParameterizedG2SameType()
      //@Error: FULL_RESOLUTION: METHOD_DUPLICATED
      var as G2 of (Integer, Integer): G2()
      assert var?

//EOF