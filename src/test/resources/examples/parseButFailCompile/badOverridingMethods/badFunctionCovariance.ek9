#!ek9
<?-
  Test to detect invalid return types via covariance on funtions with the same signature.
-?>
defines module bad.functions.covariance.examples

  defines trait
    T1
      someMethod()
        <- rtn <- true

    T2 extends T1
      override someMethod()
        <- rtn <- false

  defines function

    BaseFunction as abstract
      -> arg0 as T1
      <- rtn as Boolean?

    //This is valid as it meets the signature and implements the interface
    ValidCovariance is BaseFunction as abstract
      -> arg0 as T1
      <- rtn as Boolean: arg0?

    //While this does accept the incoming parameter, it alters the return type
    @Error: FULL_RESOLUTION: COVARIANCE_MISMATCH
    InvalidCovariance1 is BaseFunction as abstract
      -> arg0 as T1
      <- rtn as T1: arg0

    //In this example there is not return being sent and so it does not meet the interface.
    @Error: FULL_RESOLUTION: COVARIANCE_MISMATCH
    InvalidCovariance2 is BaseFunction as abstract
      -> arg0 as T1
      assert arg0?

    @Error: FULL_RESOLUTION: FUNCTION_SIGNATURE_DOES_NOT_MATCH_SUPER
    InvalidIncomingParameters1 is BaseFunction as abstract
      ->
        arg0 as Float
        arg1 as T1
      <- rtn as Boolean: true

    @Error: FULL_RESOLUTION: FUNCTION_SIGNATURE_DOES_NOT_MATCH_SUPER
    InvalidIncomingParameters2 is BaseFunction as abstract
      -> arg0 as Float
      <- rtn as Boolean: false

//EOF