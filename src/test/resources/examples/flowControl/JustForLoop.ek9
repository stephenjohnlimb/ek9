#!ek9
defines module com.customer.just.loops

  defines function
    workHours()
      -> time as Time
      <- workTime as Boolean: time < 12:00 or time > 14:00

    messagePrefix()
      <- rtn <- "SomePrefix-"

  defines program
    collectionsForLoop()
      stdout <- Stdout()
      
      stdout.println("Strings")      
      for item in ["Alpha", "Beta", "Charlie"]
        stdout.println(item)

      //Now examples with guard, assignment and declaration
      prefix <- String()
      for prefix ?= messagePrefix() then item in ["Alpha", "Beta", "Charlie"]
        stdout.println(`${prefix}${item}`)

      for prefix: messagePrefix() then item in ["Alpha", "Beta", "Charlie"]
        stdout.println(`${prefix}${item}`)

      for newPrefix <- messagePrefix() then item in ["Alpha", "Beta", "Charlie"]
        stdout.println(`${newPrefix}${item}`)

      stdout.println("Characters1")
      //The alternative is when you already have an iterator
      moreItems <- ['A', 'B', 'C']
      for item in moreItems.iterator()
        stdout.println(item)

      stdout.println("Characters while")
      itemIter1 <- moreItems.iterator()
      while itemIter1.hasNext()
        item <- itemIter1.next()
        stdout.println(item)

      //Now a while with a guard, so reuse the iter from above but reset
      while itemIter1 ?= moreItems.iterator() then itemIter1.hasNext()
        item <- itemIter1.next()
        stdout.println(item)

      //Same again but with an assignment
      while itemIter1 := moreItems.iterator() then itemIter1.hasNext()
        item <- itemIter1.next()
        stdout.println(item)

      //This time declare a new iterator, but with the while loop
      while itemIterX <- moreItems.iterator() then itemIterX.hasNext()
        item <- itemIterX.next()
        stdout.println(item)

      stdout.println("Characters do/while")  
      itemIter2 <- moreItems.iterator()

      if itemIter2.hasNext()
        do
          item <- itemIter2.next()
          stdout.println(item)  
        while itemIter2.hasNext()

      //The above is a bit clumsy, so lets try this instead
      //This has the same effect, assuming the iterator came back as unset
      do itemIter2 ?= moreItems.iterator() then
        item <- itemIter2.next()
        stdout.println(item)
      while itemIter2.hasNext()

      //Now a loop withing a loop
      stdout.println("Loop in Loop")  
      for item in moreItems
        stdout.println(item)
        for innerItem in item
          stdout.println(innerItem)
    
    integerForLoop()
      stdout <- Stdout()
      for i in 1 ... 10
        stdout.println(`Value [${i}]`)
         
      for i in 1 ... 9 by 2
        stdout.println(`Value [${i}]`)
        
    floatForLoop()
      stdout <- Stdout()
      
      //So you could do a calculation to get this value
      incrementer <- 6.3
      for i in 8.2 ... 30.0 by incrementer
        stdout.println(`Value [${i}]`)
        
      //descending  
      for i in 90.0 ... 70.0 by -5.0
        stdout.println(`Value [${i}]`)
        
    timeForLoop()
      stdout <- Stdout()
      
      //From 9-5 every half hour
      start <- Time().startOfDay() + PT9H
      end <- Time().endOfDay() - PT6H30M
      thirtyMinutes <- PT30M
      
      //Be aware that time loops around.
      for i in start ... end by thirtyMinutes
        stdout.println(`Value [${i}]`)

    timePipeLine()
      stdout <- Stdout()
      
      //From 9-5 every half hour
      start <- Time().startOfDay() + PT9H
      end <- Time().endOfDay() - PT6H30M
      thirtyMinutes <- PT30M
            
      for i in start ... end by thirtyMinutes | filter by workHours > stdout    

    collectionsPipeLine()
      stdout <- Stdout()

      items <- ["Alpha", "Beta", "Charlie"]
      cat items > stdout

      capturedValues <- List() of String
      cat ["Alpha", "Beta", "Charlie"], ["Delta", "Echo"] | tee in capturedValues > stdout

      //The alternative is when you already have an iterator
      moreItems <- ['A', 'B', 'C']
      iter <- moreItems.iterator()
      cat iter > stdout

    <?-
      Example of how a 'guard' can be used to wrap a for with an 'if not unset'.
      The same guard logic as used with if, switch, try, do, while can be employed with 'for'.
    -?>
    forLoopWithGuard()
      stdout <- Stdout()
      prefix as String?
      for prefix ?= messagePrefix() then i in 1 ... 10
        stdout.println(`${prefix}${i}`)

    <?-
      The assignment of a variable but just at the start of a for loop.
    -?>
    forLoopWithAssignment()
      stdout <- Stdout()
      prefix as String?
      for prefix: messagePrefix() then i in 1 ... 10
        stdout.println(`${prefix}${i}`)

    <?-
      The declaration of a variable but just at the start of a for loop.
    -?>
    forLoopWithDeclaration()
      stdout <- Stdout()
      for prefix <- messagePrefix() then i in 1 ... 10
        stdout.println(`${prefix}${i}`)

    <?-
      Now see how the new for 'expression' looks.
      It looks and feels nice.
      //TODO add some tests on missing rtn in expression use
      //Also adding a return in a normal statement is pointless / like switch/try
    -?>
    forLoopAsExpression()
      result <- for i in 1 ... 10
        <- rtn <- 0
        rtn += i
      assert result?

    <?-
      Here is the while loop as an expression that can return a value.
    -?>
    whileLoopAsExpression()
      result <- while check <- false then not check
        <- rtn <- 0
        rtn++
        check: rtn == 10
      assert result?

    <?-
      Here is the do/while loop as an expression that can return a value.
    -?>
    doLoopAsExpression()
      result <- do check <- false
        <- rtn <- 0
        rtn++
        check: rtn == 10
      while not check

      assert result?
//EOF
