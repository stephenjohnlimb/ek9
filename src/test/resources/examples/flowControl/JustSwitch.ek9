#!ek9
defines module com.customer.just.switches

  defines function

    <?-
      Function to be used later in switch statements.
      Also an example of a pure function that has strict assignment rules
      this also demonstrates how the 'if/else' check for all paths resulting
      in values being initialised.
    -?>
    currentTemperature() as pure
      -> country as String
      <- temp as Integer?

      if country == "GB"
        temp :=? 20
      else if country == "DE"
        temp :=? 41
      else
        temp :=? 31

  defines program

    ABooleanSwitchExample()
      conditionVariable <- true

      //This is the reason that an ifExpression is not needed.
      //You get the same effect with this mechanism
      resultValue <- given conditionVariable
        <- result String: String()
        when true
          result: "Steve"
        default
          //Just put some statements in here to demo block use.
          var1 <- "something"
          var2 <- "somethingElse"
          assert var1? and var2?
          result: "Stephen"

      assert resultValue?

    AnotherBooleanSwitchExample()
      conditionVariable <- true

      //This is the reason that an ifExpression is not needed.
      //Note that as this returns a value 'default' can be omitted.
      resultValue <- given conditionVariable
        <- result String: String()
        when true
          result: "Steve"

      assert resultValue?

      //The alternative for such a simple block above is a ternary
      //So only use the above if you have multiple block statements.
      //But if you have lots of block statement - use a function and just call that.

      //Here is a simple ternary
      resultValue2 <- conditionVariable <- "Steve" else "Stephen"
      assert resultValue2?

    ASimpleSwitch()
      stdout <- Stdout()
      multiplier <- 5
      //This is what we will use to 'switch on'
      conditionVariable <- 21

      //This is what we will vary based on the condition variable
      resultText <- String()

      switch conditionVariable
        case < 12
          resultText: "Moderate"
        case > 10*multiplier
          resultText: "Very High"
        case 25, 26, 27
          resultText: "Slightly High"
        case currentTemperature("GB"), 21, 22, 23, 24
          resultText: "Perfect"
        default
          resultText: "Not Suitable"

      stdout.println(resultText)

      //The same switch could have been written using given and when
      given conditionVariable
        when < 12
          resultText: "Moderate"
        when > 10*multiplier
          resultText: "Very High"
        when 25, 26, 27
          resultText: "Slightly High"
        when currentTemperature("GB"), 21, 22, 23, 24
          resultText: "Perfect"
        default
          resultText: "Not Suitable"

      stdout.println(resultText)

    AReturningSwitch()
      stdout <- Stdout()
      //This is what we will use to 'switch on'
      conditionVariable <- "Name"

      resultText <- switch conditionVariable
        <- result String: String()
        case 'D'
          result: "Inappropriate"
        case matches /[nN]ame/
          result: "Perfect"
        case > "Gandalf"
          result: "Moderate"
        case < "Charlie"
          result: "Very High"
        default
          result: "Suitable"

      stdout.println(resultText)

    <?-
      Example of declaring a variable and then using a guard.
      If the guard resulted in 'not set' then resultText would also be not set (because result is an unset String)
      and the switch would not have even been executed (nor any case functions).
      Note you can use either 'with' or 'then' to join the guard to the switch variable.
    -?>
    ASwitchWithGuard()
      stdout <- Stdout()
      temperature <- Integer()
      multiplier <- 5
      resultText <- switch temperature ?= currentTemperature("GB") with temperature
        <- result String: String()
        case < 12
          result: "Moderate"
        case > 10*multiplier
          result: "Very High"
        case 25, 26, 27
          result: "Slightly High"
        case 21, 22, 23, 24
          result: "Perfect"

      stdout.println(resultText)

    <?-
      In this case an assignment is used, this means that 'temperature' could still be unset.
      But unlike the guard above, the switch still executes, but now the code must be able to deal with unset.
      This is the 'default' case.
      Note you can use either 'with' or 'then' to join the assignment to the switch variable.
    -?>
    ASwitchWithAssignment()
      -> multiplier as Integer
      stdout <- Stdout()
      temperature <- Integer()
      resultText <- switch temperature := currentTemperature("GB") with temperature
        <- result String: String()
        case < 12
          result: "Moderate"
        case > 10*multiplier
          result: "Very High"
        case 25, 26, 27
          result: "Slightly High"
        case 21, 22, 23, 24
          result: "Perfect"

      stdout.println(resultText)

    <?-
      Now in this case, rather than use a guard, it uses a declaration of the new variable.
      'temperature' is only visible within the switch block.
      Note you can use either 'with' or 'then' to join the declaration to the switch variable.
    -?>
    switchWithDeclaration()
      -> multiplier as Integer
      stdout <- Stdout()
      resultText <- switch temperature <- currentTemperature("GB") with temperature
        <- result String: String()
        case < 12
          result: "Moderate"
        case > 10*multiplier
          result: "Very High"
        case 25, 26, 27
          result: "Slightly High"
        case 21, 22, 23, 24
          result: "Perfect"

      stdout.println(resultText)

      //So this means the 'temperature' defined above is now out of scope and so
      //can be redeclared and used here
      temperature <- "Some other value"
      assert temperature?

//EOF
