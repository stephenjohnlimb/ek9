package org.ek9lang.compiler.backend.jvm;

import java.io.FileOutputStream;
import java.io.IOException;
import org.ek9lang.compiler.backend.ConstructTargetTuple;
import org.ek9lang.compiler.common.INodeVisitor;
import org.ek9lang.compiler.ir.Construct;
import org.ek9lang.compiler.ir.Operation;
import org.ek9lang.core.AssertValue;
import org.ek9lang.core.CompilerException;

/**
 * The visitor that uses an AsmStructureCreator to produce jvm bytecode for a Construct.
 * Intertwines the generation of the JVM ASM codee with double dispatch visiting of the IR Model.
 */
public final class OutputVisitor implements INodeVisitor {

  private final ConstructTargetTuple constructTargetTuple;

  //The ASM code that will do the bytecode writing
  private final AsmStructureCreator asmStructureCreator;

  public OutputVisitor(final ConstructTargetTuple constructTargetTuple) {
    AssertValue.checkNotNull("File cannot be null", constructTargetTuple.targetFile());
    this.constructTargetTuple = constructTargetTuple;
    asmStructureCreator = new AsmStructureCreator(constructTargetTuple, this);
  }

  @Override
  public void visit() {
    visit(constructTargetTuple.construct());

    //So that should be it, as long as each IR Node has been asked to accept this visitor
    //then with the double dispatch each of the relevant IRNodes in the code should have been visited.
    final var byteCodes = asmStructureCreator.getByteCode();

    try (var stream = new FileOutputStream(constructTargetTuple.targetFile())) {
      stream.write(byteCodes);
      System.out.println("Saved bytecodes to file " + constructTargetTuple.targetFile());
    } catch (IOException e) {
      System.err.println("Failed to save bytecodes to file " + constructTargetTuple.targetFile());
      throw new CompilerException("Unable to s generated bytecode", e);
    }
  }

  @Override
  public void visit(final Construct construct) {
    asmStructureCreator.processClass();
  }

  @Override
  public void visit(final Operation operation) {
    asmStructureCreator.processMethodOnClass(operation);
  }

}
