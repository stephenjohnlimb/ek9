<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>EK9 programming language flow control</title>
  <meta content="EK9 programming language flow control
    has all the normal controls such as if/else/switch/for/do/while but also cat for streaming." name="description"/>
  <link href="style.css" media="all" rel="stylesheet"/>
  <link href="ek9favicon.png" rel="icon" type="image/png"/>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-6GS00TXGVP"></script>
  <script>
      window.dataLayer = window.dataLayer || [];

      function gtag() {
          dataLayer.push(arguments);
      }

      gtag('js', new Date());

      gtag('config', 'G-6GS00TXGVP');

  </script>
</head>
<body>
<nav role="navigation">
  <header role="banner">
    <h1 id="logo">
      <a aria-label="EK9lang.org" href="https://www.ek9lang.org/" role="img" title="ek9lang.org">
        EK9lang.org
      </a>
    </h1>
    <p>
      <a href="tradeMarkPolicy.html">&reg;</a>
    </p>
  </header>

  <h2>
    V: 0.0.1
  </h2>
  <p>
    &#169; 2020-2025 S.J.limb
  </p>

  <ul>
    <li><a class="reference internal" href="index.html">About EK9</a></li>
    <li><a class="reference internal" href="introduction.html">Introduction</a></li>
    <li><a class="reference internal" href="structure.html">Structure</a></li>
    <li><a class="reference internal" href="basics.html">Basics</a></li>
    <li><a class="reference internal" href="operators.html">Operators</a></li>
    <li><a class="reference internal" href="builtInTypes.html">Built in Types</a></li>
    <li><a class="reference internal" href="collectionTypes.html">Collection Types</a></li>
    <li><a class="reference internal" href="standardTypes.html">Standard Types</a></li>
    <li><a class="reference internal" href="networkTypes.html">Network Types</a></li>
    <li><a class="reference internal" href="programs.html">Programs</a></li>
    <li><a class="reference internal" href="constants.html">Constants</a></li>
    <li><a class="reference internal" href="flowControl.html">Flow Control</a></li>
    <li><a class="reference internal" href="exceptions.html">Exceptions/Error Handling</a></li>
    <li><a class="reference internal" href="enumerations.html">Enumerations</a></li>
    <li><a class="reference internal" href="records.html">Records</a></li>
    <li><a class="reference internal" href="functions.html">Functions</a></li>
    <li><a class="reference internal" href="classes.html">Classes</a></li>
    <li><a class="reference internal" href="methods.html">Methods</a></li>
    <li><a class="reference internal" href="traits.html">Traits</a></li>
    <li><a class="reference internal" href="composition.html">Extension by Composition</a></li>
    <li><a class="reference internal" href="inheritance.html">Inheritance</a></li>
    <li><a class="reference internal" href="dynamicFunctions.html">Dynamic Functions</a></li>
    <li><a class="reference internal" href="dynamicClasses.html">Dynamic Classes</a></li>
    <li><a class="reference internal" href="streamsAndPipelines.html">Streams/Pipelines</a></li>
    <li><a class="reference internal" href="advancedClassMethods.html">Advanced Class Methods</a></li>
    <li><a class="reference internal" href="generics.html">Generics/Templates</a></li>
    <li><a class="reference internal" href="textProperties.html">Text/Properties</a></li>
    <li><a class="reference internal" href="components.html">Components and Applications</a></li>
    <li><a class="reference internal" href="dependencyInjection.html">Dependency Injection</a></li>
    <li><a class="reference internal" href="webServices.html">Web Services</a></li>
    <li><a class="reference internal" href="commonDesignPatterns.html">Design Patterns</a></li>
    <li><a class="reference internal" href="packaging.html">Packaging</a></li>
    <li><a class="reference internal" href="commandline.html">Command Line</a></li>
  </ul>
</nav>

<main role="main">
  <article class="page">
    <header>
      <h1>Flow Control in EK9</h1>
    </header>
    <p>
      EK9 has a range of syntax that enables a developer to control the flow of processing.
      These are broadly what you would expect in a general programming language and are similar to most other programming languages.
      <br/>
      But there are a couple of additions in EK9 that mean you may not need to use these imperative (traditional) flow control
      statements quite as much. There are also a number of enhancements that make flow control much easier in EK9.
    </p>
    <p>
      See this <a href="https://blog.ek9.io/flow-control-why-no-early-returns">article</a> on why there are no early returns
      during <i>function/method</i> body processing and flow controls.
    </p>
    <h2>The Controls</h2>
    <p>
      In general it has been found that adopting a more <i>functional</i> approach to flow control leads to
      a decrease in developer cognitive load, simplicity, flexibility, reduction in code volume, more code
      reuse and fewer defects.<br/>
      Linked with the new EK9 operators; traditional flow control is needed much less (but in some cases it is
      still required).
    </p>
    <p>
      The examples shown below start with simple version of each flow-control syntax and then show the additional features in EK9.
    </p>
    <p>
      The traditional flow control mechanisms available are broadly categorised as follows:
    </p>
    <h5>Branching</h5>
    <ul>
      <li><a href="#if_elseif_else">If, Else If ,Else</a> - conditional processing based on a boolean expression
      </li>
      <li><a href="#switch">Switch</a> - conditional processing but based on variable value</li>
      <li><a href="#try_catch">Try</a> - see <a href="exceptions.html">Exceptions</a> - as the flow control is out
        of the current scope block (but should be 'exceptional').
      </li>
    </ul>
    <h5>Looping (imperative/procedural)</h5>
    <ul>
      <li><a href="#for_loop">For</a> - traditional for loop but with extras like support for
        collections/iterators
      </li>
      <li><a href="#while_loop">While</a> - traditional while loop with boolean control</li>
      <li><a href="#do_while_loop">Do While</a> - traditional do/while loop with boolean control</li>
    </ul>
    <h5>Streaming (more functional)</h5>
    <p>
      Most of the above processing can also be implemented using this more functional technique.
    </p>
    <ul>
      <li><a href="#for_stream">For</a> - used with literals to pipe a variable into a stream</li>
      <li><a href="#cat_stream">Cat</a> - used with a collection to pipe each element into a stream</li>
    </ul>

    <h3>Control examples</h3>
    <p>
      Examples of the different types of flow control are show below in the next sections.
    </p>
    <h4 id="if_elseif_else">If statements</h4>
    <p>
      A traditional control statement - but also review <a href="operators.html#ternary">ternary operators</a> and
      <a href="operators.html#assignment_coalescing">assignment coalescing</a>.
      You may find that syntax much more appealing and terse in certain situations. See
      <a href="operators.html#contrast_if_else_ternary">contrast of if/else and ternary operators</a>
      for common situations and especially for dealing with variables that may be <b>un-set</b>.
    </p>
    <p>
      But when you really do need an <i>if</i> statement EK9 has a number of additional features that give you
      more control and flexibility.
    </p>
    <h5 id="simple_if_elseif_else">Simple If statements</h5>
    <p>
      This is the 'if/else' in its simplest form.
    </p>
    <pre>#!ek9
defines module introduction

  defines function

    testIfElseInteger()
      -> first as Integer

      trigger <- false

      if first > 21
        trigger: true
      else if first < 10
        trigger: false
      else
        trigger: Boolean()

      //Just ensure referenced
      assert trigger?

    testIfElseIntegerAsPure() as pure
      -> first as Integer

      trigger <- Boolean()

      if first > 21
        trigger :=? true
      else if first < 10
        trigger :=? false

      //Just ensure referenced
      assert trigger?
//EOF</pre>
    <br/>
    <p>
      The above example <i>testIfElseInteger</i> should be fairly straightforward to understand, basically depending on the value of
      <i>first</i>, the value of <i>trigger</i> is altered.
    </p>
    <p>
      The second example <i>testIfElseIntegerAsPure</i> above, highlights how the <b>pure</b> keyword can be used.
      This has a more strict use/reuse of variables and assignment. Note the use of <b>:=?</b> this is the assignment
      (but only when the 'left-hand-side' is <b>un-set</b>).
    </p>
    <h5 id="sort_of_if_with_range">Range </h5>
    <p>
      This is a sort of <i>if statement</i> but with a very specific and defined use.
      It incorporates the EK9 concept of <i>range</i>s of values. It is very useful and terse for simple situations where a
      developer need to check if a value is or is not within a specific range.
    </p>
    <pre>#!ek9
defines module introduction

  defines function

    kotlinLikeRangeCheck()
      ->
        value as Integer
        lowerBound as Integer
        upperBound as Integer

      stdout <- Stdout()

      isWithin <- value in lowerBound ... upperBound
      stdout.println(`${value} is within a range of ${lowerBound} ... ${upperBound}: ${isWithin}`)

      isNotWithin <- value not in 16-2 ... upperBound-1

      stdout.println(`${value} is NOT within a range of 16-2 ... ${upperBound - 1}: ${isNotWithin}`)

//EOF</pre>
    <br/>
    <p>
      The example above shows how checks can be made on a variable to check they are (or are not) within a specific
      range of values. Note that the start and end values can be calculated values and also in the form of expressions.
      <br/>
      In someways it is similar to a <i>ternary</i> expression or a very simple <i>if expression</i> (EK9 uses switch for this type of
      flow control - where the conditions of more complex).
    </p>
    <h5 id="boolean_logic_with_if">If statement with boolean logic</h5>
    <p>
      Simple example of using combination boolean logic as part of the <i>if</i> statement.
    </p>
    <pre>#!ek9
defines module introduction

  defines function

    currentTemperature() as pure
      -> country as String
      <- temp as Integer: Integer()

      if country == "GB"
        temp :=? 20
      else if country == "DE"
        temp :=? 41

    simpleIf()
      stdout <- Stdout()

      suitableValue <- String()
      valueToTest <- 9

      if valueToTest < 10
        stdout.println(`Value ${valueToTest} is less than 10`)

      secondValue <- 21
      specialCondition <- true

      if valueToTest < 10 and secondValue > 19 or specialCondition
        stdout.println("Test OK")

      //The same logic as above - but in a different layout.
      if valueToTest < 10 and
      secondValue > 19 or
      specialCondition
        stdout.println("Test OK")

      //Rather than use the keyword 'if' you can use 'when'
      when valueToTest < 10
        stdout.println(`Value ${valueToTest} is less than 10`)

      //As you would expect it is possible to chain if and else statements
      if valueToTest > 9
        suitableValue: "Too High"
      else if valueToTest < 9
        suitableValue: "Too Low"
      else
        suitableValue: "Just Right"

      stdout.println(suitableValue)
//EOF</pre>
    <br/>
    <p>
      This example (above) shows alternative syntax and layout and combination logic expressions.
    </p>
    <h5 id="if_with_assignment_guard_declaration">If statement with assignment/guard and declaration</h5>
    <p>
      In the same sort of way the <i>switch</i> (see later) supports guard, assignment and declarations as part of its structure,
      the <i>if</i> statement has the same features.
    </p>
    <pre>#!ek9
defines module introduction

  defines function

    currentTemperature() as pure
      -> country as String
      <- temp as Integer: Integer()

      if country == "GB"
        temp :=? 20
      else if country == "DE"
        temp :=? 41

    assignmentInIf()
      stdout <- Stdout()

      //Note that this value is 'unset' in the sense it has no meaningful value
      selectedTemperature <- Integer()

      //See if we can find some hot temperature somewhere so in the US we have no idea! because value is unset
      when selectedTemperature := currentTemperature("US") with selectedTemperature > 50
        stdout.println(`Temp of ${selectedTemperature} a little warm in the US`)
      else when selectedTemperature := currentTemperature("US") with selectedTemperature < 50
        stdout.println(`Temp of " + ${selectedTemperature} not too bad in the US`)
      else when selectedTemperature := currentTemperature("GB") with selectedTemperature > 40
        stdout.println(`Temp of " + ${selectedTemperature} a little warm in the UK`)
      else when selectedTemperature := currentTemperature("DE") with selectedTemperature > 40
        stdout.println(`Temp of ${selectedTemperature} a little warm in the DE`)
      else
        stdout.println("Not sure where it might be warm")

    guardedAssignmentInIf()
      stdout <- Stdout()

      selectedTemperature <- Integer()

      //Here we use a guarded assignment checks for null and unset and only then does the conditional check
      //Also note we can still use 'if' and rather than 'with' use 'then'
      when selectedTemperature ?= currentTemperature("US") with selectedTemperature > 50
        stdout.println("Temp of " + $selectedTemperature + " a little warm in the US")
      else when selectedTemperature ?= currentTemperature("US") with selectedTemperature < 50
        stdout.println("Temp of " + $selectedTemperature + " not too bad in the US")
      else if selectedTemperature ?= currentTemperature("GB") with selectedTemperature > 40
        stdout.println("Temp of " + $selectedTemperature + " a little warm in the UK")
      else when selectedTemperature ?= currentTemperature("DE") then selectedTemperature > 40
        stdout.println("Temp of " + $selectedTemperature + " a little warm in the DE")
      else
        stdout.println("Not sure where it might be warm")

    declarationInIf()
      stdout <- Stdout()
      when selectedTemperature <- currentTemperature("US") with selectedTemperature > 50
        stdout.println("Temp of " + $selectedTemperature + " a little warm in the US")
      else when selectedTemperature ?= currentTemperature("US") with selectedTemperature < 50
        stdout.println("Temp of " + $selectedTemperature + " not too bad in the US")
      else if selectedTemperature := currentTemperature("GB") with selectedTemperature > 40
        stdout.println("Temp of " + $selectedTemperature + " a little warm in the UK")
      else when selectedTemperature: currentTemperature("DE") then selectedTemperature > 40
        stdout.println("Temp of " + $selectedTemperature + " a little warm in the DE")
      else
        stdout.println("Not sure where it might be warm")
//EOF</pre>
    <br/>
    <h5>If statement summary</h5>
    <p>
      The main points in the examples of 'if statements' above are:
    </p>
    <ul>
      <li>The use of <b>when</b> rather than <b>if</b> in some cases - developer choice</li>
      <li>The use of an assignment <b>:=</b> as part of the <b>if</b> statement</li>
      <li>The use of the guarded assignment <b>?=</b> as part of the <b>if</b> statement</li>
      <li>The use of a variable declaration <b>&larr;</b> as part of the <b>if</b> statement</li>
      <li>The calling of <i>function</i> <u>currentTemperature</u> only when needed in <b>else if</b></li>
      <li>Ideally all conditions in an <b>if</b> statement are on the same line</li>
      <li>If multiple lines for <b>if</b> statements are needed then they must align as above.</li>
    </ul>
    <p>
      <b>Note</b> that if there are multiple if/else statements and those have <b>declarations</b> of variables,
      those variables are then available in other else/if scopes after the declaration (as part of the main if scope block).
      But sure you want to do this - as it may become confusing or hard to refactor later.
    </p>
    <p>
      In addition, the use of '?=' guards and the use of '&larr;' mandate that the resulting variable type must have
      the '?' is-set operator. This is so that the guard functionality can evaluate whether the result is set or not.
    </p>
    <p>
      Being able to incorporate an assignment within the <b>if</b> or <b>else if</b> really
      does help to reduce the number of variables that are needed to created and assigned
      before the <b>if</b> statement block. The guarded assignment is particularly useful as the
      <i>condition</i> part of the if statement is not evaluated if the guarded assignment resulted in
      <b>isSet == false</b>.
    </p>
    <p>
      In general, the use of the declaration/assignment or guarded assignment reads better with <b>when</b> rather
      than <b>if</b>, but this is developer choice. As you can see, the combination of ternary operators and the
      addition of assignments and guarded assignments really adds quite a lot of functionality to
      conditional flow control. This is augmented further in the switch statement that follows.
    </p>
    <p>
      The guarded assignment is very useful for dealing with methods or functions that may return <b>un-set</b> values as
      they keep the additional checks much simpler.
    </p>
    <p>
      The next section covers the <i>switch</i> statement/expression - which is designed to take over when there are many
      conditions to consider.
    </p>
    <h4 id="switch">Switch</h4>
    <p>
      The <i>switch</i> in EK9 is similar in someways to the <i>if/else</i> type flow; the ordering of cases is important.
      It also supports multiple and varied matches and can be used to <b>return</b> a value
      like an expression. Just like the <b>if</b> statement it can also use alternative keywords.
    </p>
    <p>
      When the <i>switch</i> is used an enumeration it works more like a traditional <i>switch</i> as seen in other programming languages.
      Indeed, it then mandates that all enumeration values are handled by a specific <i>case</i> (and <i>default</i> condition must also be provided).
    </p>
    <p>
      Most importantly the <i>switch statement</i> can also be a <i>switch expression</i> - this means that the switch can actually
      return a value. Importantly there must always be a <i>default</i> case with the <i>switch</i>.
    </p>
    <p>
      The examples below show some different uses of the <i>switch</i> statement/expression.
    </p>
    <h5 id="switch_simple_enumeration">Switch on Enumerated Values</h5>
    <p>
      This is the most similar use of a <i>switch statement</i> when compared to other programming languages, but even then
      it has some very strict semantics.<br/>
      When used with an 'enumeration', where the <i>case</i> statements refer directly to
      an enumerated value - <b>all</b> enumerated values must be defined in a <i>case</i>.<br>
      A <i>default</i> must also be provided for situations where the value being 'switched over' is <b>un-set</b>.
    </p>
    <p>
      The <i>switch</i> is shown below in 'expression' form, but can also be used as a 'statement'.
    </p>
    <pre>#!ek9
defines module introduction
  defines type

    &lt;?-
      This is the enumeration that is used in the example below.
      It is finite in the number of values it can hold.
    -?&gt;
    LimitedEnum
      A,
      B,
      C,
      D

  defines function

    SimpleExhaustiveEnumerationExpressionSwitch()
      -> val as LimitedEnum

      result <- switch val
        <- rtn as String?
        case LimitedEnum.A
          rtn: "Just A"
        case LimitedEnum.B
          rtn: "Just B"
        case LimitedEnum.C
          rtn: "Just C"
        case LimitedEnum.D
          rtn: "Just D"
        default
          rtn: "Val is not set"

      assert result?
//EOF</pre>
    <br/>
    <p>
      The example above, shows the definition of a simple 'Enumerated type', then when provided with a variable
      'val' which is of the 'Enumerated type' <b>LimitedEnum</b>; a <i>switch expression</i> is used to compare that value with each of
      the values in the 'Enumerated type'. Note the use of the returning values from the <i>switch expression</i>.
    </p>
    <p>
      When used this way <i>switch</i> requires all enumerated values to appear in a <i>case</i> and a <i>default</i> statement.
      In this way the <i>switch</i> is <u>exhaustive</u> in its semantic checking. The EK9 compiler will issue errors if not all enumerated values are
      present or if the <i>default</i> statement is missing.
    </p>
    <p>
      You might consider this too 'strict', but it has a significant advantage in highlighting common errors that present themselves when
      additional values are added to the 'Enumerated type'. In this situation existing code will fail to compile when an additional
      enumerated value is added to the 'Enumerated type'. This is a positive situation because it now forces the developer to assess the processing.
    </p>
    <p>
      If you do not want to deal with each enumerated value explicitly, there is a simple and elegant solution to this.
      This is shown in the following example.
    </p>
    <pre>
...
  defines function

    SimpleNonExhaustiveEnumerationExpressionSwitch()
      -> val as LimitedEnum

      result <- switch val
        <- rtn as String?
        case == LimitedEnum.A
          rtn: "Just A"
        default
          rtn: "Val is anything but A"

      assert result?
//EOF</pre>
    <br/>
    <p>
      By simply making one of the <i>case</i> statements operate as an 'expression' in this case using the <b>==</b> (equality) operator,
      the exhaustive nature of the <i>switch</i> statement is <b>turned off</b>. Now if additional enumerated values are added to the
      'Enumerated type' they automatically get dealt with in the <i>default</i> block.
    </p>
    <p>
      This provides a less strict <i>switch</i>, similar to many other programming languages.
    </p>
    <h5 id="switch_like_if_expression">Switch form similar to an if expression</h5>
    <p>
      The following example, shows how a <i>switch expression</i> can be employed in a similar manner to an 'if expression'.
    </p>
    <pre>#!ek9
defines module introduction

  defines function
    SimpleSwitchExampleWithTernaryAsAnAlternative()
      -> conditionVariable as Boolean

      //This is the reason that an ifExpression is not needed.
      resultValue <- given conditionVariable
        <- result String?
        when true
          result: "Steve"
        default
          result: "Not Steve"

      assert resultValue?

      //But above could just have been a ternary
      resultValue2 <- conditionVariable <- "Steve" else "Not Steve"
      assert resultValue2?
//EOF</pre>
    <br/>
    <p>
      The above example highlights why EK9 does not have an 'if expression', the <i>switch</i> is so flexible and
      can be used as an expression (as shown) that it provides all the functionality needed.<br/>
      However, for simple expressions like this a 'ternary statement' (also shown) could have been used.
    </p>
    <p>
      When the blocks in the 'when true' or <i>default</i> statements are multiline the 'ternary' would not have been
      usable and the <i>switch expression</i> with larger blocks would have been more appropriate.
    </p>
    <h5 id="switch_statement">Switch in statement form</h5>
    <p>
      The following example, shows a simple <i>switch statement</i>, but with expressions as part of the <i>case</i> statements.<br/>
      The alternative syntax of <i>given/when</i> rather than <i>switch</i>/<i>case</i> is also shown.
    </p>
    <p>
      This example also highlights the use of the 'pure' syntax and the necessary change in semantics to ensure variables
      are only assigned to when unset (this is the <b>:=?</b> syntax).
    </p>
    <pre>#!ek9
defines module introduction

  defines function

    currentTemperature() as pure
      -> country as String
      <- temp as Integer: Integer()

      if country == "GB"
        temp :=? 20
      else if country == "DE"
        temp :=? 41

    ASimpleSwitchStatement() as pure
      -> conditionVariable as Integer
      multiplier <- 5

      //This is what we will vary based on the condition variable
      resultText1 <- String()

      switch conditionVariable
        case < 12
          resultText1 :=? "Moderate"
        case > 10*multiplier
          resultText1 :=? "Very High"
        case 25, 26, 27
          resultText1 :=? "Slightly High"
        case currentTemperature("GB"), 21, 22, 23, 24
          resultText1 :=? "Perfect"
        default
          resultText1 :=? "Not Suitable"

      assert resultText1?

      resultText2 <- String()
      //The same switch could have been written using given and when
      given conditionVariable
        when < 12
          resultText2 :=? "Moderate"
        when > 10*multiplier
          resultText2 :=? "Very High"
        when 25, 26, 27
          resultText2 :=? "Slightly High"
        when currentTemperature("GB"), 21, 22, 23, 24
          resultText2 :=? "Perfect"
        default
          resultText2 :=? "Not Suitable"

      assert resultText2?

//EOF</pre>
    <br/>
    <p>
      As you can see rather than just matching absolute single values in the <b>case</b>, EK9
      supports a wide range of matches. This makes it very important that you present the order
      correctly, as EK9 will only match the first in the list. It is also <b>very</b> important
      that when using functions in the match there are no <u>side effects</u> from those functions.
    </p>
    <p>
      Unlike other programming languages there is no <b>break</b> or <b>yield</b> use. There is no
      <i>case</i> 'fall-through'; this catered for by allowing multiple expression conditions per <i>case</i>.
    </p>
    <p>
      The switch in EK9 has been given great power and versatility - take care with it. Elect to do
      the simplest matching where ever possible.
    </p>
    <h5 id="switch_expression">Switch in expression form</h5>
    <p>
      This example shows a function in 'pure' form again. This time the <i>switch</i> has a return value and is
      used as an expression. The use of <i>switch</i> in expression form fits well with the 'pure' nature of only
      assigning a value to a variable once. It also shows some of the other <i>case</i> expression conditions.
    </p>
    <pre>#!ek9
defines module introduction

  defines function

    ASwitchAsExpression() as pure
      -> conditionVariable as String

      //This is more like a chained if/else with expressions in the <i>case</i>
      resultText <- switch conditionVariable
        <- result String?
        case 'D'
          result :=? "Inappropriate"
        case matches /[nN]ame/
          result :=? "Perfect"
        case > "Gandalf"
          result :=? "Moderate"
        case < "Charlie"
          result :=? "Very High"
        default
          result :=? "Suitable"

      assert resultText?
//EOF</pre>
    <br/>
    <p>
      In the <b>ASwitchAsExpression</b> example above you can see how the <i>switch</i> is used in an expression
      that both declares a new variable <b>resultText</b> and initialises it from the <b>return</b>
      value from the <i>switch</i>.
    </p>
    <p>
      As shown above, it is possible to match <i>String</i> values with both lexical comparison and
      regular expression matches. Just to reiterate - focus on the ordering of the list in the switch
      statement. If you've used other languages then the switch statement tends to only match single values.
      EK9 introduces range matching and while this is more powerful it requires much <u>more focus</u> to get
      right.
    </p>
    <h5 id="switch_with_conditions">Switch with a guard/assignment/declaration condition</h5>
    <p>
      The concept of a guard expression is much like a containing 'if statement'.
      In this example if the returning value from 'currentTemperature' was 'un-set' then the variable
      'temperature' would remain 'un-set'. If that was the case then the whole switch expression would not be
      evaluated at all. This would mean that 'resultText' would also be 'un-set'.
    </p>
    <p>
      The assignment and declaration form always process the <i>switch</i> statement, it's just the declaration is completed
      inside the <i>switch</i> scope.
    </p>
    <pre>#!ek9
defines module introduction

  defines function

    currentTemperature() as pure
      -> country as String
      <- temp as Integer: Integer()

      if country == "GB"
        temp :=? 20
      else if country == "DE"
        temp :=? 41

    ASwitchWithGuard()
      temperature <- Integer()
      multiplier <- 5
      resultText <- switch temperature ?= currentTemperature("GB") with temperature
        <- result String: String()
        case < 12
          result: "Moderate"
        case > 10*multiplier
          result: "Very High"
        case 25, 26, 27
          result: "Slightly High"
        case 21, 22, 23, 24
          result: "Perfect"
        default
          result: "Suitable"

      assert resultText?

    ASwitchWithAssignment()
      -> multiplier as Integer

      temperature <- Integer()
      resultText <- switch temperature := currentTemperature("GB") with temperature
        <- result String: String()
        case < 12
          result: "Moderate"
        case > 10*multiplier
          result: "Very High"
        case 25, 26, 27
          result: "Slightly High"
        case 21, 22, 23, 24
          result: "Perfect"
        default
          result: "Suitable"

      assert resultText?

    ASwitchWithDeclaration()
      -> multiplier as Integer

      resultText <- switch temperature <- currentTemperature("GB") with temperature
        <- result String: String()
        case < 12
          result: "Moderate"
        case > 10*multiplier
          result: "Very High"
        case 25, 26, 27
          result: "Slightly High"
        case 21, 22, 23, 24
          result: "Perfect"
        default
          result: "Suitable"

      assert resultText?

      //So this means the 'temperature' defined above is now out of scope and so
      //can be declared a-fresh and used here
      temperature <- "Some other value"
      assert temperature?

//EOF</pre>
    <br/>
    <p>
      One final point, the switches in EK9 <b>must</b> have a <b>default</b> and there is no
      <u>fall through</u> (and hence no <b>break</b> keyword like in C/C++/C#/Java). The
      <u>fall through</u> capability is delivered by allowing multiple values per <i>case</i>.
    </p>
    <p>
      A lot of capability and flexibility has been added into the <i>switch</i>.
      The EK9 <i>switch</i> is much more like an <i>if/else</i> chain than a <i>switch</i> from C, C++ or Java.
    </p>
    <h4 id="try_catch">Try Catch and Exceptions</h4>
    <p>
      Whilst Try, Catch and Exceptions are a form of <u>flow control</u>. The flow control is one
      of processing an error state. It is not designed and should <b>not</b> be used to control
      normal flow. In some ways <i>Exceptions</i> are a form of
      <a href="https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF" target="_blank" title="GOTO"><b>GOTO</b></a>
      statement (as are <b>break</b> and <b>return</b> - but in a slightly more controlled manner).
      In general, whilst many programming languages have a widespread use of Exceptions; these tend to pervade
      all API's and force alterations in interfaces.
      EK9 prefers the use of <b>unSet</b> variables, <b>Result</b> and the careful and selective use of Exceptions.
      See the section on <a href="exceptions.html">Exceptions/Error Handling</a> for more details.
    </p>
    <p>
      EK9 is in general much less likely to throw an Exception and is more likely to return values that
      are <b>unSet</b> or a <b>Result</b> type. This means that the caller must be prepared for values that
      have not been <b>set</b>.
      This is the general ethos in EK9. Exceptions really should be thrown in <u>exceptional circumstances</u>,
      and <b>never</b> as a design mechanism for flow control.
    </p>

    <h4 id="for_loop">For Loops - but with extras</h4>
    <p>
      Loops are normally employed when need to perform the same set of operations over some set of data.
      <br/>
      There is quite a bit of flexibility with <b>for loops</b>. A key point to note that with EK9, there is no
      <b>break</b> and no <b>return</b> statement; so you cannot exit for loops early (this is by design). See
      <a href="introduction.html#break_return">EK9 philosophy</a> for a discussion on the reasoning for this.
    </p>
    <p>
      <b>For</b> loops in EK9 are intended and designed to run from <u>end to end</u>; all the way through,
      if you are looking to stop processing some way through a loop then consider using a <b>while loop</b>,
      <a href="#for_stream">streaming for loops</a> or <a href="#cat_stream">streaming collections</a>.
    </p>
    <h5>Standard For Loop</h5>
    <p>
      The example below shows a standard traditional loop with an integer variable.
      There are a couple of things to note here:
    </p>
    <ul>
      <li>The loop variable type is inferred</li>
      <li>The use of <b>'...'</b> indicates an inclusive <i>range</i></li>
      <li>The incrementer amount can be specified</li>
      <li>Its use is not limited to Integers, any type with the appropriate <i>operators</i> can be used</li>
    </ul>
    <pre>#!ek9
defines module introduction

  defines function

    ForLoopExample1
      stdout <- Stdout()

      for i in 1 ... 10
        stdout.println(`Value [${i}]`)

    ForLoopExample2
      stdout <- Stdout()

      for i in 0 ... 10 by 2
        stdout.println(`Value [${i}]`)

    ForLoopExample3
      stdout <- Stdout()

      j <- 2
      for i in 0 ... 10 by j
        stdout.println(`Value [${i}]`)

    ForLoopExample4
      stdout <- Stdout()

      j <- -2
      for i in 10 ... 0 by j
        stdout.println(`Value [${i}]`)

    ForLoopAsExpression()
      result <- for i in 1 ... 10
        <- rtn <- 0
        rtn += i
      assert result?

//EOF</pre>
    <br/>
    <p>
      Please note the spaces around <b>'...'</b>; these are required.
    </p>
    <p>
      Importantly it is also possible to use a <i>for</i> loop in the form of an expression that returns a value. This is
      shown above in function 'ForLoopAsExpression'.
    </p>
    <h5>For Loop with other types</h5>
    <p>
      In the above example an Integer was used, these examples below show the <b>for</b> loop has much
      more flexibility. Indeed, it can be used with any types (even those created by EK9 developers) as long
      as the appropriate comparison/addition/subtraction operators are provided.
    </p>
    <pre>#!ek9
defines module introduction

  defines function

    FloatForLoop()
      stdout <- Stdout()

      //So you could do a calculation to get this value
      incrementer <- 6.3
      for i in 8.2 ... 30.0 by incrementer
        stdout.println(`Value [${i}]`)

      //descending
      for i in 90.0 ... 70.0 by -5.0
        stdout.println(`Value [${i}]`)

    TimeForLoop()
      stdout <- Stdout()

      //From 9-5:30 every half hour
      start <- Time().startOfDay() + PT9H
      end <- Time().endOfDay() - PT6H30M
      thirtyMinutes <- PT30M

      //Be aware that time loops around.
      for i in start ... end by thirtyMinutes
        stdout.println(`Value [${i}]`)
//EOF</pre>
    <br/>
    <p>
      Hopefully now you can see the additional power and flexibility the EK9 <b>for</b> loop has.
    </p>
    <ul>
      <li>It can be used with different types</li>
      <li>It can be used ascending or descending</li>
      <li>The loop variable type is inferred and is immutable (developers cannot alter its value directly)</li>
      <li>Variables can be used for the start and end of the range and also the incrementer</li>
      <li>By providing your own <b>constructs</b> with the right operators enables them to be used in 'for' loops</li>
      <li>It can be used as an expression, returning a value</li>
    </ul>
    <h5>For Loop with collections</h5>
    <p>
      Unlike some other Object-Oriented languages; EK9 does not attach <b>for loop</b> syntax to <i>Collection</i>
      objects, nor does it attach <b>stream</b> syntax.
      <br/>
      It approaches the traversal of objects held within <i>Collections</i> in <b>two</b> different,
      but complementary ways. The first of which is shown below and the second is shown in
      <a href="#cat_stream">streaming collections</a>
    </p>
    <pre>#!ek9
defines module introduction

  defines function

    CollectionsForLoop()
      stdout <- Stdout()

      stdout.println("Strings")
      for item in ["Alpha", "Beta", "Charlie"]
        stdout.println(item)

      stdout.println("Characters")
      //The alternative is when you already have an iterator
      moreItems <- ['A', 'B', 'C']
      for item in moreItems.iterator()
        stdout.println(item)
//EOF</pre>
    <br/>
    <p>
      The loop variable's type is inferred from the Collection or Iterator.
      The <b>for</b> loop on Collections can be used with any <i>type</i> that has an <i>iterator()</i>
      method that returns an <a href="collectionTypes.html#iterator">Iterator</a> or with an object with type that has
      two methods below (which is a bit of a 'Duck Type' approach):
    </p>
    <ul>
      <li>hasNext() - returning a Boolean</li>
      <li>next() - returning a type other than Void</li>
    </ul>
    <p>
      The example above shows a <b>List of String</b> being used in a <b>for</b> loop and also the <i>Iterator</i>
      from a
      <b>List of Characters</b>.
    </p>
    <h5>For Loop assignments, guards and declarations</h5>
    <p>
      In the same way the 'assignments', 'guards' and 'declarations' can be used with <i>if</i> and
      <i>switch</i> statements/expressions, they can also be used with <i>for</i> loops. This is shown below.
    </p>
    <pre>#!ek9
defines module introduction

  defines function

    messagePrefix()
      <- rtn <- "SomePrefix-"

    forLoopWithGuard()
      stdout <- Stdout()

      prefix as String?
      for prefix ?= messagePrefix() then i in 1 ... 10
        stdout.println(`${prefix}${i}`)

    forLoopWithAssignment()
      stdout <- Stdout()

      prefix as String?
      for prefix: messagePrefix() then i in 1 ... 10
        stdout.println(`${prefix}${i}`)

    forLoopWithDeclaration()
      stdout <- Stdout()

      for prefix <- messagePrefix() then i in 1 ... 10
        stdout.println(`${prefix}${i}`)

      //Just to highlight that 'prefix' in the for loop - was scoped in the for loop only.
      prefix <- 21
      assert prefix?
//EOF</pre>
    <br/>
    <p>
      The capability to add variable initialisation as part of the <i>for</i> loop makes is consistent with
      most of the other EK9 flow control syntax.
    </p>

    <h4 id="for_stream">Streaming 'For'</h4>
    <p>
      There are times when the values generated by a <b>for</b> loop are useful in a processing pipeline. The
      example below
      shows this with the addition of some filtering.
    </p>
    <pre>#!ek9
defines module introduction

    workHours() as pure
      -> time as Time
      <- workTime as Boolean: time < 12:00 or time > 14:00

  defines program

    TimePipeLine()
      stdout <- Stdout()

      //From 9-5:30 every half hour
      start <- Time().startOfDay() + PT9H
      end <- Time().endOfDay() - PT6H30M
      thirtyMinutes <- PT30M

      for i in start ... end by thirtyMinutes | filter by workHours > stdout
//EOF</pre>
    <br/>
    <p>
      In the example above, the <b>for</b> loop is used to generate a sequence of times and these are then
      'piped' into a processing pipeline and processed by the <i>function</i> 'workHours'. The pipeline
      then looks at the result of the filter and only outputs the time to the next stage of processing if 'true'.
      Hence, 'stdout' only gets the times that are before 12:00 and after 14:00.
    </p>
    <p>
      Hopefully from this example you can see how the omission of <b>break</b> and <b>return</b> doesn't really
      present a major issue and how you can un-bundle nested loops (always tricky) into processing pipelines.
      But it also means that the bit of logic you might have nested in the <b>for</b> loop has been pulled out to
      a function (that can be tested, re-used and altered with ease).
    </p>
    <p>
      This different syntax and approach does take a little time to get used to. If you notice, where
      an <b>if</b> statement to determine the work hours, this has been implemented with a simple boolean
      expression (predicate) in the <i>function</i> 'workHours'.
      While you may think this a <i>trivial</i> point - after all you still had to write the same
      boolean expression. You also had to write the <i>function</i> which is much more text than 'if'. The overall
      approach has moved from being procedural to being more declarative.
    </p>
    <p>
      By using <b>head</b> with the pipeline processing you can cut short the streaming of objects through the pipeline.
      As soon as <b>head</b> has process the number of objects you requested it will trigger the shutdown of the pipeline.
      This is very much like <b>break</b> and <b>return</b>. So if; for example you were looking for a particular value in
      a collection or a generated list, you can use a <b>filter</b> to select the right one; then <b>head</b>
      to stop processing once one value with that criteria comes through the pipeline. Clearly it may be the case
      that the value <u>never</u> comes through the pipeline (if the value was not contained).
    </p>
    <p>
      One final point; the Streaming 'For' is the main reason there are no <u>List Comprehensions</u> in EK9.
      While the syntax in EK9 and the need for <i>functions</i> means more code is required
      (than List Comprehensions in Python), it makes the code more readable and fits the
      <a href="introduction.html#break_return">EK9 philosophy</a>.
    </p>
    <p>
      This approach also brings standardisation to functional processing flow. So unlike other languages (such as Java) where specific
      methods are attached to specific 'Functional types', EK9 has the functional processing syntax built in to the language itself.
    </p>
    <h4 id="cat_stream">Streaming Collections</h4>
    <p>
      As with the <b>for</b> loop above and the <b>streaming for</b> it is possible to send all the contents of
      collections through a processing pipeline rather than just looping over them.
    </p>
    <pre>#!ek9
defines module introduction

  defines program  
    collectionsPipeLine()
      stdout <- Stdout()

      items <- ["Alpha", "Beta", "Charlie"]
      cat items > stdout

      //The alternative is when you already have an iterator
      moreItems <- ['A', 'B', 'C']
      iter <- moreItems.iterator()
      cat iter > stdout

      //An example of 'teeing' content out of a processing stream
      capturedValues <- List() of String
      cat ["Alpha", "Beta", "Charlie"], ["Delta", "Echo"] | tee in capturedValues > stdout
      assert capturedValues?

//EOF</pre>
    <br/>
    <p>
      By introducing the <b>cat</b> command syntax, EK9 has removed the need to attach <b>for/stream</b> syntax to
      collection classes themselves. This gives much more flexibility and consistency in developed code.
      In effect the developer just 'streams' the contents of a collection (or some sort of source, like an
      iterator) into a processing pipeline.
    </p>
    <p>
      In the example above there is no real processing in the pipeline, the contents are just written to
      <b>stdout</b>.
      <br/>
      But part of the example above shows two 'lists of Strings' being streamed, <b>tee</b> off into a collection to be used
      later and also streamed to <b>stdout</b>.
      There is much more detail on pipeline processing in section <a href="streamsAndPipelines.html">Streams/Pipelines</a>.
    </p>
    <h3>While and Do/While loops</h3>
    <p>
      The final two loop flow control mechanisms are traditional in approach. They both work on
      the value of a conditional boolean check. But they too, accommodate 'assignment', 'guard' and 'declarations'.<br/>
      They too can also be used as expressions and can return values.
    </p>
    <h4 id="while_loop">While loop examples</h4>
    <p>
      An example of a while loop, iterating over a collection of Characters, this includes a demonstration of
      the use of 'guard', 'assignment' and 'declaration syntax as well.
    </p>
    <p>
      The final function 'whileLoopAsExpression' shows the while loop being used as an expression and in conjunction
      with a variable 'declaration'.
    </p>
    <pre>#!ek9
defines module introduction

  defines function

    collectionsWhileLoop()
      stdout <- Stdout()

      moreItems <- ['A', 'B', 'C']

      stdout.println("Characters while")
      itemIter <- moreItems.iterator()
      while itemIter.hasNext()
        item <- itemIter.next()
        stdout.println(item)

      //Now a while with a guard, so reuse the iter from above but reset
      while itemIter ?= moreItems.iterator() then itemIter.hasNext()
        item <- itemIter.next()
        stdout.println(item)

      //Same again but with an assignment
      while itemIter := moreItems.iterator() then itemIter.hasNext()
        item <- itemIter.next()
        stdout.println(item)

      //This time declare a new iterator, but within the while loop
      while itemIterX <- moreItems.iterator() then itemIterX.hasNext()
        item <- itemIterX.next()
        stdout.println(item)

    whileLoopAsExpression()
      result <- while complete <- false with not complete
        <- rtn <- 0
        rtn++
        complete: rtn == 10
      assert result?

//EOF</pre>
    <br/>
    <h4 id="do_while_loop">Do/While loop example</h4>
    <p>
      This processing is similar to the above except the conditional logic is at the end of the processing block.
    </p>
    <pre>#!ek9
defines module introduction

  defines function

    collectionsDoWhileLoop()
      stdout <- Stdout()

      moreItems <- ['A', 'B', 'C']
      itemIter <- moreItems.iterator()
      if itemIter.hasNext()
        do
          item <- itemIter.next()
          stdout.println(item)
        while itemIter.hasNext()

      //The above is a bit clumsy, so lets try this instead
      //This has the same effect, when the iterator is unset
      do itemIter ?= moreItems.iterator() then
        item <- itemIter.next()
        stdout.println(item)
      while itemIter.hasNext()

    doLoopAsExpression()
      result <- do complete <- false
        <- rtn <- 0
        rtn++
        complete: rtn == 10
      while not complete

      assert result?

      //Just to show that 'complete' is bound into the do/while scope
      complete <- "Almost"
      assert complete?
//EOF</pre>
    <br/>
    <p>
      As can be seen from the examples above the 'guard' expression part when used with a <i>do/while</i>
      statement/expression makes the processing block slightly simpler. The <i>do/while</i> expression is also
      a common sort of programming 'pattern' and again the 'declaration' in the <i>do/while</i> makes this much more
      self contained.
    </p>
    <h3>Summary</h3>
    <p>
      EK9 has a wide range of flow control features, but it has deliberately excluded some of the more traditional
      syntax (like <b>break</b> for example).
      This is by design, as it is viewed that some of these elements lead to complexity and defects (a bit like <b>GOTO</b>).
    </p>
    <p>
      However, EK9 has added new syntax to traditional <b>flow control</b> syntax, this mainly being the introduction of:
    </p>

    <ul>
      <li>Guard statements</li>
      <li>Assignment statements</li>
      <li>Declaration statements</li>
      <li>Switch, For, While and Do/While in expression form</li>
    </ul>
    <p>
      The use of <a href="operators.html#ternary">ternary operators</a> and
      <a href="operators.html#assignment_coalescing">assignment coalescing</a> should be adopted in place of very simple
      <b>if/else</b> statements; they are short/succinct and expressive. However, where a range of different
      <i>methods</i> or <i>functions</i> need evaluation the <u>guarded assignment</u> in conjunction with the
      <b>if</b> statement can reduce the amount of processing.
    </p>
    <p>
      Finally if you find you need to chain many <b>if else if</b> statements together then the use of a
      <b>switch</b> statement might be appropriate. Beyond the <b>switch</b> it is sometimes best to adopt a
      <a href="collectionTypes.html#dict">Dictionary/Map</a> to solve the problem.
      <br/>While this may seem strange, remember that you can associate a <i>function</i> delegate with a key
      as part of the dictionary. This means it is possible to lookup a <i>function</i> in a dictionary and then call that <i>function</i>.
    </p>
    <p>
      It is this latter concept, that if you really do have unique values to <i>switch</i> on, then use a
      <a href="collectionTypes.html#dict">Dictionary/Map</a> - you will probably find it is faster and easier to understand.
      The use of <b>switch</b> is designed to make larger chained <b>if/else</b> blocks easier to understand.
    </p>
    <h4>Next Steps</h4>
    <p>
      The next section on <a href="exceptions.html">Exceptions</a> and <i>try</i> blocks show how error flow
      control can be implemented.
    </p>
  </article>
</main>
</body>
</html>